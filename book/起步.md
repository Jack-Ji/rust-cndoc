% 起步

本章目的是对Rust语言建立一个初步的感性认识。首先，我们将安装Rust工具包。然后，
我们会完成第一个hello world程序。最后，我们会对Rust的标准程序构建和包管理工具
cargo进行简单的描述。

# 安装Rust

注意，执行接下来的安装步骤需要电脑接入互联网。

接下来我们会在操作系统的控制终端中输入一些指令。每行指令都将`$`符号作为起始，读
者在输入这些指令时不需要敲入`$`符号，它仅是为了标识命令行的起始。我们还会在更多
的教程或示例中见到这种常用写法：`$`表示指令输入者是普通用户，`#`表示指令输入者是
超级用户或管理员。

## 平台支持

Rust编译器可在很多平台上编译和运行，但在这些平台上支持的功能并不完全一致。Rust将
所有支持的平台划分为三个梯队，支持力度也相应的由高到低。

Rust为每个支持的平台赋予了一个标识符，以下详细列出Rust对各个平台的支持情况。

### 第一梯队

Rust对第一梯队的平台的支持力度是最高的。Rust保证了在第一梯队的所有平台上均能够构
建和工作。Rust对第一梯队的平台满足的条件具体如下：

* 自动测试用例在这些平台上被打开且需运行通过；
* 新的代码在同步至`rust-lang/rust`的master分支前必须保证所有测试用例能通过；
* 官方发布的新版本包含了这些平台；
* 官方会给出在这些平台上构建和运行Rust的说明文档；

|  Target                       | std |rustc|cargo| notes                      |
|-------------------------------|-----|-----|-----|----------------------------|
| `i686-apple-darwin`           |  ✓  |  ✓  |  ✓  | 32-bit OSX (10.7+, Lion+)  |
| `i686-pc-windows-gnu`         |  ✓  |  ✓  |  ✓  | 32-bit MinGW (Windows 7+)  |
| `i686-pc-windows-msvc`        |  ✓  |  ✓  |  ✓  | 32-bit MSVC (Windows 7+)   |
| `i686-unknown-linux-gnu`      |  ✓  |  ✓  |  ✓  | 32-bit Linux (2.6.18+)     |
| `x86_64-apple-darwin`         |  ✓  |  ✓  |  ✓  | 64-bit OSX (10.7+, Lion+)  |
| `x86_64-pc-windows-gnu`       |  ✓  |  ✓  |  ✓  | 64-bit MinGW (Windows 7+)  |
| `x86_64-pc-windows-msvc`      |  ✓  |  ✓  |  ✓  | 64-bit MSVC (Windows 7+)   |
| `x86_64-unknown-linux-gnu`    |  ✓  |  ✓  |  ✓  | 64-bit Linux (2.6.18+)     |

### 第二梯队

Rust对第二梯队的平台给出的保证是能够构建成功，但不保证能够成功运行。自动测试用例
在这些平台上是处于关闭状态的。虽然如此，Rust在这些平台上均能不同程度的进行工作，
第三方贡献者的补丁也能够被及时的接受。Rust对第二梯队的平台满足的条件具体如下：

* 自动构建被打开，但不保证会运行自动测试用例；
* 新的代码在同步至`rust-lang/rust`的master分支前需保证能够构建成功。这意味着某些
  平台可能仅仅完成了标准库的编译，而另外一些平台可能完成了整个工具链和库的构建；
* 官方发布的新版本包含了这些平台；

|  Target                       | std |rustc|cargo| notes                      |
|-------------------------------|-----|-----|-----|----------------------------|
| `aarch64-apple-ios`           |  ✓  |     |     | ARM64 iOS                  |
| `aarch64-unknown-linux-gnu`   |  ✓  |  ✓  |  ✓  | ARM64 Linux (2.6.18+)      |
| `arm-linux-androideabi`       |  ✓  |     |     | ARM Android                |
| `arm-unknown-linux-gnueabi`   |  ✓  |  ✓  |  ✓  | ARM Linux (2.6.18+)        |
| `arm-unknown-linux-gnueabihf` |  ✓  |  ✓  |  ✓  | ARM Linux (2.6.18+)        |
| `armv7-apple-ios`             |  ✓  |     |     | ARM iOS                    |
|`armv7-unknown-linux-gnueabihf`|  ✓  |  ✓  |  ✓  | ARMv7 Linux (2.6.18+)      |
| `armv7s-apple-ios`            |  ✓  |     |     | ARM iOS                    |
| `i386-apple-ios`              |  ✓  |     |     | 32-bit x86 iOS             |
| `i586-pc-windows-msvc`        |  ✓  |     |     | 32-bit Windows w/o SSE     |
| `mips-unknown-linux-gnu`      |  ✓  |     |     | MIPS Linux (2.6.18+)       |
| `mips-unknown-linux-musl`     |  ✓  |     |     | MIPS Linux with MUSL       |
| `mipsel-unknown-linux-gnu`    |  ✓  |     |     | MIPS (LE) Linux (2.6.18+)  |
| `mipsel-unknown-linux-musl`   |  ✓  |     |     | MIPS (LE) Linux with MUSL  |
| `powerpc-unknown-linux-gnu`   |  ✓  |     |     | PowerPC Linux (2.6.18+)    |
| `powerpc64-unknown-linux-gnu` |  ✓  |     |     | PPC64 Linux (2.6.18+)      |
|`powerpc64le-unknown-linux-gnu`|  ✓  |     |     | PPC64LE Linux (2.6.18+)    |
| `x86_64-apple-ios`            |  ✓  |     |     | 64-bit x86 iOS             |
| `x86_64-rumprun-netbsd`       |  ✓  |     |     | 64-bit NetBSD Rump Kernel  |
| `x86_64-unknown-freebsd`      |  ✓  |  ✓  |  ✓  | 64-bit FreeBSD             |
| `x86_64-unknown-linux-musl`   |  ✓  |     |     | 64-bit Linux with MUSL     |
| `x86_64-unknown-netbsd`       |  ✓  |  ✓  |  ✓  | 64-bit NetBSD              |

### 第三梯队

Rust对第三梯队的平台的支持力度最低——新加入的代码既不保证能够构建成功，也不保证测
试用例能够运行通过，因此这些平台的构建版本可能稳定性较差。除此以外官方的发布中不
会包含这些平台，某些第三方社区可能会提供针对这些平台的发布版本。

|  Target                       | std |rustc|cargo| notes                      |
|-------------------------------|-----|-----|-----|----------------------------|
| `aarch64-linux-android`       |  ✓  |     |     | ARM64 Android              |
| `armv7-linux-androideabi`     |  ✓  |     |     | ARM-v7a Android            |
| `i686-linux-android`          |  ✓  |     |     | 32-bit x86 Android         |
| `i686-pc-windows-msvc` (XP)   |  ✓  |     |     | Windows XP support         |
| `i686-unknown-freebsd`        |  ✓  |  ✓  |  ✓  | 32-bit FreeBSD             |
| `x86_64-pc-windows-msvc` (XP) |  ✓  |     |     | Windows XP support         |
| `x86_64-sun-solaris`          |  ✓  |  ✓  |     | 64-bit Solaris/SunOS       |
| `x86_64-unknown-bitrig`       |  ✓  |  ✓  |     | 64-bit Bitrig              |
| `x86_64-unknown-dragonfly`    |  ✓  |  ✓  |     | 64-bit DragonFlyBSD        |
| `x86_64-unknown-openbsd`      |  ✓  |  ✓  |     | 64-bit OpenBSD             |

注意，第三梯队的平台数目会随着时间不停增长，上表给出的只是部分较为典型的平台。

## 在Linux或Mac上安装

如果你所运行的是Linux或Mac系统，只需打开终端软件并输入以下指令即可：

```bash
$ curl -sSf https://static.rust-lang.org/rustup.sh | sh
```

这条指令会下载并执行一个脚本，该脚本负责了安装工作。如果一切顺利，你会看到如下输
出信息：

```text
Rust is ready to roll.
```

从这里开始，输入`y`代表'yes'，之后按照提示进行操作即可。

## 在Windows上安装

如果你使用的是Windows系统，请下载[安装包][install-page]。

[install-page]: https://www.rust-lang.org/install.html

## 卸载

卸载Rust同样非常简单。在Linux或者Mac系统上，执行以下指令即可：

```bash
$ sudo /usr/local/lib/rustlib/uninstall.sh
```

在Windows系统上，你可以重新运行`.msi`安装包，里面会给出卸载选项。

## 检查安装结果

完成安装后，打开终端并输入以下指令：

```bash
$ rustc --version
```

如果一切正常，你应该能够看到版本号、最近一次提交的hash值和日期。

能够看到以上信息就表明你已经成功的安装了Rust！恭喜你！

如果你没能看到以上信息并且你运行的Windows系统，请检查Rust是否被加入到了%PATH%环
境变量中：`$ echo %PATH%`。若没有则重新运行安装包并选择"Change"选项，确认“Add to
PATH”选项被选中。如果你想手动设置环境变量，Rust的可执行文件所在路径可能是
`"C:\Program Files\Rust stable GNU 1.x\bin"`。

Rust本身不负责链接工作，因此你需要确保系统中有可用的链接器。具体请查询文档。

如果还是看不到以上信息，你可以在下面几个地方寻求帮助。最容易的方式是通过
使用irc.mozilla.org上的两个irc聊天频道`#rust-beginners`和`#rust`。
你可通过[Mibbit网站][mibbit]提供的服务直接进入这些频道。在这些频道中你可以自由
的和其他Rustaceans（rust开发者的昵称）交流相关话题。其它可获取帮助的渠道还
有[Rust用户论坛][users]和[Stack Overflow网站][stackoverflow]。

[mibbit]: http://chat.mibbit.com/?server=irc.mozilla.org&channel=%23rust-beginners,%23rust
[users]: https://users.rust-lang.org/
[stackoverflow]: http://stackoverflow.com/questions/tagged/rust

Rust安装包在安装工具链和库的同时还会安装一份文档，因此我们可以离线查阅文档。在
UNIX系统上，`/usr/local/share/doc/rust`是安装文档的地址（译者注：如果是通过
rustup脚本安装的则可通过`$ rustup doc`命令打开文档）。在Windows系统上，文档被放
置在Rust安装目录下的`share/doc`目录。

# Hello, world!

完成了Rust的安装后，我们就可以开始写第一个Rust程序了。理所当然的，第一个程序的工
作就是向终端输出“Hello, world!”。

## 创建工程

首先，创建一个目录用于放置你的Rust代码。Rust本身不关心代码如何存放，但是在本文中
我们建议创建一个目录作为工程的根目录。打开终端并输入下列指令：

```bash
$ mkdir ~/projects
$ cd ~/projects
$ mkdir hello_world
$ cd hello_world
```

> 注意：如果你是在Windows系统中，建议使用PowerShell作为终端，否则`~`符号不能代表
> home目录。

## 编写程序

接下来就是创建一个文件并输入源码，文件命名为*main.rs*。Rust文件总是以*.rs*作为
结尾。如果你在文件名中使用了多个单词，应使用下划线将它们隔开。例如：你应该使用
*hello_world.rs*而不是*helloworld.rs*作为文件名。

下面就是我们的第一个Rust程序的源码：

```rust
fn main() {
    println!("Hello, world!");
}
```

保存好文件后返回终端，在UNIX系统上，输入以下指令：

```bash
$ rustc main.rs
$ ./main
Hello, world!
```

在Windows系统上，将`./main`替换为`main.exe`。无论是什么操作系统，最终你都会在
终端上看到字符串`Hello, world!`。至此，你已经完成了一个Rust程序，恭喜你！

## 程序剖析

现在，让我们分析一下源码，看看到底发生了什么。

```rust
fn main() {

}
```

以上三行代码的功能是定义了一个函数。和C/C++一样，`main`函数在Rust中有特殊的意义，
它被作为了整个程序的入口点，即程序是从main函数开始执行的。第一行代码声明了函数
的原型：函数名为`main`，没有入参也没有返回。在函数有入参的情况下，参数声明会被
放置在圆括号之中。由于main函数什么都不会返回，函数的返回部分是被忽略掉的。

整个函数体是被围绕在一对花括号之中的，这是Rust语法所要求的。将左花括号和函数声明
放置在同一行在Rust文化中被认为是不错的编码风格。

`main()`函数的实现：

```rust
    println!("Hello, world!");
```

这行代码实现了程序的所有功能：向终端输出字符串。有几点值得注意：1）程序以四个空
格作为缩进，而不是制表符；2）`println!`是对Rust宏的调用，这涉及到了Rust对元编程
的支持。如果我们是调用函数而不是宏，那么在调用符号的末尾不会有`!`符号。我们会在
后面的教程中详细描述Rust宏，现在你只需要知道`!`意味着对宏的调用即可。

接下来是`"Hello, world!"`字符串。字符串在系统编程语言中是个较为复杂的话题（相当
令人惊讶）。上面的代码使用了一个静态分配的字符串。我们将该字符串作为参数传递给了
`println!`，然后即可在屏幕上得到该字符串的输出。

上面的代码以分号作（`;`）为结尾。Rust是个以表达式为核心的语言，语言中的大部分元
素都是表达式。末尾的`;`意味着一个表达式已经结束，另一个可以开始了。Rust代码中的
大部分行都是以`;`作为结束符的。

## 编译和运行

在“编写程序”一节中，我们已经展示了如何运行新写的程序。现在我们将步骤拆分开逐个
进行分析。

在运行Rust程序之前，你首先需要将其进行编译。你可以使用Rust的编译器`rustc`，将源
文件作为编译器的输入接口，具体如下：

```bash
$ rustc main.rs
```

如果你具备C/C++的编程经验，你会发现这和`gcc`或`clang`的用法很类似。在编译成功后，
Rust会输出二进制文件，在UNIX系统上你可以通过在终端内输入`ls`命令将其列出：

```bash
$ ls
main  main.rs
```

在Windows系统上，你应该输入如下命令：

```bash
$ dir
main.exe
main.rs
```

由命令输出我们可以看到两个文件：源文件（以`.rs`结尾），二进制文件（Windows下是
`main.exe`，UNIX环境下是`main`）。接下来我们可以运行程序：

```bash
$ ./main  # or .\main.exe on Windows
```

如果*main.rs*是你的“Hello, world!”程序，终端上会输出`Hello, world!`。

如果你之前使用的是Ruby、Python或Javascript这样的动态语言，你可能会对先编译后运
行的做法感到不适应。Rust是一门*ahead-of-time compiled*语言，意为你可以将程序编译
好之后发送给其他人，而收到二进制程序的人可以直接将其运行而无需安装Rust。反之如果
你给了某人一个`.rb`、`py`或`js`文件，他需要在自己的电脑上先安装了Ruby、Python或
Javascript的某个实现后才能运行代码。

直接使用`rustc`编译源码对hello world这样的小程序来讲是足够了。但随着工程规模的
增长，你需要管理工程的各种选项，并且需要能方便的将你的代码共享给其他人或其它工
程。下面我们将为你介绍工具`Cargo`，它将会帮助你编写真正的rust程序。

# 你好Cargo！

Cargo是Rust的标准构建和包管理工具，基本上所有Rust工程都是由Cargo来管理的。Cargo
可管理三样东西：工程自身的源码、第三方依赖库的下载以及编译。

我们所编写的Rust程序不存在任何依赖，因此目前你还用不到Cargo的依赖项管理功能。随
着你编写的Rust程序越来越复杂，你会需要加入其它依赖项，使用Cargo会让这一切变得非
常简单。

随着越来越多的Rust工程开始使用Cargo，我们在接下来的教程中默认你也使用了Cargo作为
Rust工程的管理工具。Cargo工具默认属于Rust工具链的一部分，因此你只需安装官方的
Rust安装包即可。在终端内输入以下指令可检查Cargo工具是否可用：

```bash
$ cargo --version
```

## 使用Cargo管理工程

下面我们来将之前编写的Hello World程序改成通过Cargo进行管理。需要的步骤如下：

1. 将代码存放到合适的位置；
2. 删除编译输出的二进制文件；
3. 创建一个Cargo配置文件；

开始吧！

### 创建源码目录并删除二进制文件

首先，在终端上进入*hello_world*目录，并执行如下指令：

```bash
$ mkdir src
$ mv main.rs src/main.rs # or 'move main.rs src/main.rs' on Windows
$ rm main  # or 'del main.exe' on Windows
```

Cargo默认会在*src*目录下查找所有的源代码，我们的第一步由此而来。根目录
（*hello_world*）下还可用于存放README、许可证、软件文档等与源码不直接相关的资料。
通过这样的方式，Cargo使得你的工程结构清晰而整洁。

现在，将*main.rs*移入*src*目录，并且删除`rustc`编译输出的二进制文件。

在这个例子中源码文件的名称仍然保持为`main.rs`，因为我们最终要生成的是一个可执行
文件。如果你想生成的是一个库文件，文件应该被命名为`lib.rs`。这个是Cargo编译工程
的默认规则，当然你也可以在配置中对其进行修改。

### 创建配置文件

在*hello_world*目录中创建`Cargo.toml`文件。

确保文件名`Cargo.toml`的首字母是大写的，否则Cargo将找不到配置文件。

这个文件的格式是*[TOML]*(Tom's Obvious, Minimal Language)。TOML的格式类似于INI，
但是有一些额外的扩展。

[TOML]: https://github.com/toml-lang/toml

在`Cargo.toml`文件中，敲入以下信息：

```toml
[package]

name = "hello_world"
version = "0.0.1"
authors = [ "Your name <you@example.com>" ]
```

第一行的`[package]`表示接下来的内容是用于配置软件包的选项。后面我们还会见到其它
的类型的配置项，在本例中我们只有`package`一种配置项。

另外三行配置分别设置了Cargo需要了解的工程的三个信息：名称、版本和作者。

## 构建和运行Cargo工程

准备好了配置文件你就可以使用Cargo工具构建和运行程序了！具体方式如下：

```bash
$ cargo build
   Compiling hello_world v0.0.1 (file:///home/yourname/projects/hello_world)
$ ./target/debug/hello_world
Hello, world!
```

万岁！终于又看到`Hello, world!`了！

上面是通过`./target/debug/hello_world`运行了编译结果，实际上你可以很简单的通过
命令`cargo run`来运行程序：

```bash
$ cargo run
     Running `target/debug/hello_world`
Hello, world!
```

注意上面的命令没有导致工程被重新构建，这是因为Cargo能够判断出源码在上次成功编译
后没有发生改变，因此直接运行了上次编译的结果。如果你对源码做出了改动，Cargo会自
动重新构建工程，然后再运行编译结果。具体示例如下：

```bash
$ cargo run
   Compiling hello_world v0.0.1 (file:///home/yourname/projects/hello_world)
     Running `target/debug/hello_world`
Hello, world!
```

对一个简单的程序来讲，Cargo并没有带来很多的改进。但是随着程序规模的增加，Cargo的
作用会愈加显著，尤其是当程序开始使用crate（等同于其它语言中的库或软件包）时。对
于由多个crate构成的复杂工程来讲，Cargo工具会带来很多便利性——输入
`cargo build`命令即可一切搞定！

### 生成Release版本

当工程已经做好了发布的准备，你可以使用`cargo build --release`命令为工程构建打开
优化开关。这些优化会使你的Rust代码更快的运行，然而编译所花费的时间也会更久。这就
是为什么我们有两套构建配置，一套用于正常开发，另一套用于发布版本。

### `Cargo.lock`是什么?

执行`cargo build`后你会在当前目录下发现一个新文件`Cargo.lock`，其内容大概如下：

```toml
[root]
name = "hello_world"
version = "0.0.1"
```

Cargo使用*Cargo.lock*文件来跟踪工程的依赖项。由于我们的hello world工程没有其它
依赖，这个文件的内容看起来较少。在现实的工程中，你很少需要去管*Cargo.lock*文件，
把它交给Cargo就好。

到现在为止，我们已经成功的使用Cargo工具管理了我们的hello world工程。

尽管这是个很小的工程，你已经通过它熟悉了在接下来的Rust职业生涯中会用到的大部分
工具和命令。事实上，你可以认为所有的的Rust工程或多或少都是通过如下的指令序列
来构建的：

```bash
$ git clone someurl.com/foo
$ cd foo
$ cargo build
```

## 快速创建Cargo工程

事实上以上步骤并不是创建一个新工程最简易的方法，Cargo提供了创建新工程的快速命令，
基于这些命令你可以很方便的进行开发工作！

创建一个新的工程只需执行`cargo new`命令即可：

```bash
$ cargo new hello_world --bin
```

上面的命令包含了`--bin`选项，这是要告诉Cargo我们创建的工程要生成的目标文件是个
可执行文件，而不是一个库。

Cargo为我们生成了两个文件和一个目录：Cargo.toml、src目录及src/main.rs。看起来很
眼熟吧？没错，这和我们上面手动建立的工程结构一模一样！

打开`Cargo.toml`文件，内容如下：

```toml
[package]

name = "hello_world"
version = "0.1.0"
authors = ["Your Name <you@example.com>"]

[dependencies]
```

暂时不必关心`[dependencies]`，这个我们留待后述。

Cargo根据你传给它的参数和`git`的全局配置自动设置了工程的选项。你也许注意到
`hello_world`目录已经被`git`初始化过了。

下面是`src/main.rs`的内容：

```rust
fn main() {
    println!("Hello, world!");
}
```

Cargo已经为你自动生成了"Hello World!"的代码，你可以开始编码了！

> 注意：如果你想更多的了解Cargo工具，请查阅官方的[Cargo guide]，那里包含了对
> Cargo所有特性的描述。

[Cargo guide]: http://doc.crates.io/guide.html

# 结束语

本章概括了Rust的一些基础知识。具备了这些基础，你就可以很顺利的进行接下来的学习了。

你有两个选择：1）阅读分析[一个小例子][guessinggame]；
2）从[基本语法和语义][syntax]开始逐渐学习。有经验的系统程序师可能更倾向于从代码
示例开始学习，不具备静态语言经验的程序员则相反。条条大道通罗马，请自己选择哪种
方式更适合自己！

[guessinggame]: 一个小例子.md
[syntax]: 语法和语义.md
