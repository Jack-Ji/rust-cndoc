% 起步

本章目的是对Rust语言建立一个初步的感性认识。首先，我们将安装Rust工具包。然后，
我们会完成第一个hello world程序。最后，我们会对Rust的标准程序构建和包管理工具
cargo进行简单的描述。

# 安装Rust

注意，执行接下来的安装步骤需要电脑接入互联网。

接下来我们会在操作系统的控制终端中输入一些指令。每行指令都将`$`符号作为起始，读
者在输入这些指令时不需要敲入`$`符号，它仅是为了标识命令行的起始。我们还会在更多
的教程或示例中见到这种常用写法：`$`表示指令输入者是普通用户，`#`表示指令输入者是
超级用户或管理员。

## 平台支持

Rust编译器可在很多平台上编译和运行，但在这些平台上支持的功能并不完全一致。Rust将
所有支持的平台划分为三个梯队，支持力度也相应的由高到低。

Rust为每个支持的平台赋予了一个标识符，以下详细列出Rust对各个平台的支持情况。

### 第一梯队

Rust对第一梯队的平台的支持力度是最高的。Rust保证了在第一梯队的所有平台上均能够构
建和工作。Rust对第一梯队的平台满足的条件具体如下：

* 自动测试用例在这些平台上被打开且需运行通过；
* 新的代码在同步至`rust-lang/rust`的master分支前必须保证所有测试用例能通过；
* 官方发布的新版本包含了这些平台；
* 官方会给出在这些平台上构建和运行Rust的说明文档；

|  Target                       | std |rustc|cargo| notes                      |
|-------------------------------|-----|-----|-----|----------------------------|
| `i686-apple-darwin`           |  ✓  |  ✓  |  ✓  | 32-bit OSX (10.7+, Lion+)  |
| `i686-pc-windows-gnu`         |  ✓  |  ✓  |  ✓  | 32-bit MinGW (Windows 7+)  |
| `i686-pc-windows-msvc`        |  ✓  |  ✓  |  ✓  | 32-bit MSVC (Windows 7+)   |
| `i686-unknown-linux-gnu`      |  ✓  |  ✓  |  ✓  | 32-bit Linux (2.6.18+)     |
| `x86_64-apple-darwin`         |  ✓  |  ✓  |  ✓  | 64-bit OSX (10.7+, Lion+)  |
| `x86_64-pc-windows-gnu`       |  ✓  |  ✓  |  ✓  | 64-bit MinGW (Windows 7+)  |
| `x86_64-pc-windows-msvc`      |  ✓  |  ✓  |  ✓  | 64-bit MSVC (Windows 7+)   |
| `x86_64-unknown-linux-gnu`    |  ✓  |  ✓  |  ✓  | 64-bit Linux (2.6.18+)     |

### 第二梯队

Rust对第二梯队的平台给出的保证是能够构建成功，但不保证能够成功运行。自动测试用例
在这些平台上是处于关闭状态的。虽然如此，Rust在这些平台上均能不同程度的进行工作，
第三方贡献者的补丁也能够被及时的接受。Rust对第二梯队的平台满足的条件具体如下：

* 自动构建被打开，但不保证会运行自动测试用例；
* 新的代码在同步至`rust-lang/rust`的master分支前需保证能够构建成功。这意味着某些
  平台可能仅仅完成了标准库的编译，而另外一些平台可能完成了整个工具链和库的构建；
* 官方发布的新版本包含了这些平台；

|  Target                       | std |rustc|cargo| notes                      |
|-------------------------------|-----|-----|-----|----------------------------|
| `aarch64-apple-ios`           |  ✓  |     |     | ARM64 iOS                  |
| `aarch64-unknown-linux-gnu`   |  ✓  |  ✓  |  ✓  | ARM64 Linux (2.6.18+)      |
| `arm-linux-androideabi`       |  ✓  |     |     | ARM Android                |
| `arm-unknown-linux-gnueabi`   |  ✓  |  ✓  |  ✓  | ARM Linux (2.6.18+)        |
| `arm-unknown-linux-gnueabihf` |  ✓  |  ✓  |  ✓  | ARM Linux (2.6.18+)        |
| `armv7-apple-ios`             |  ✓  |     |     | ARM iOS                    |
|`armv7-unknown-linux-gnueabihf`|  ✓  |  ✓  |  ✓  | ARMv7 Linux (2.6.18+)      |
| `armv7s-apple-ios`            |  ✓  |     |     | ARM iOS                    |
| `i386-apple-ios`              |  ✓  |     |     | 32-bit x86 iOS             |
| `i586-pc-windows-msvc`        |  ✓  |     |     | 32-bit Windows w/o SSE     |
| `mips-unknown-linux-gnu`      |  ✓  |     |     | MIPS Linux (2.6.18+)       |
| `mips-unknown-linux-musl`     |  ✓  |     |     | MIPS Linux with MUSL       |
| `mipsel-unknown-linux-gnu`    |  ✓  |     |     | MIPS (LE) Linux (2.6.18+)  |
| `mipsel-unknown-linux-musl`   |  ✓  |     |     | MIPS (LE) Linux with MUSL  |
| `powerpc-unknown-linux-gnu`   |  ✓  |     |     | PowerPC Linux (2.6.18+)    |
| `powerpc64-unknown-linux-gnu` |  ✓  |     |     | PPC64 Linux (2.6.18+)      |
|`powerpc64le-unknown-linux-gnu`|  ✓  |     |     | PPC64LE Linux (2.6.18+)    |
| `x86_64-apple-ios`            |  ✓  |     |     | 64-bit x86 iOS             |
| `x86_64-rumprun-netbsd`       |  ✓  |     |     | 64-bit NetBSD Rump Kernel  |
| `x86_64-unknown-freebsd`      |  ✓  |  ✓  |  ✓  | 64-bit FreeBSD             |
| `x86_64-unknown-linux-musl`   |  ✓  |     |     | 64-bit Linux with MUSL     |
| `x86_64-unknown-netbsd`       |  ✓  |  ✓  |  ✓  | 64-bit NetBSD              |

### 第三梯队

Rust对第三梯队的平台的支持力度最低——新加入的代码既不保证能够构建成功，也不保证测
试用例能够运行通过，因此这些平台的构建版本可能稳定性较差。除此以外官方的发布中不
会包含这些平台，某些第三方社区可能会提供针对这些平台的发布版本。

|  Target                       | std |rustc|cargo| notes                      |
|-------------------------------|-----|-----|-----|----------------------------|
| `aarch64-linux-android`       |  ✓  |     |     | ARM64 Android              |
| `armv7-linux-androideabi`     |  ✓  |     |     | ARM-v7a Android            |
| `i686-linux-android`          |  ✓  |     |     | 32-bit x86 Android         |
| `i686-pc-windows-msvc` (XP)   |  ✓  |     |     | Windows XP support         |
| `i686-unknown-freebsd`        |  ✓  |  ✓  |  ✓  | 32-bit FreeBSD             |
| `x86_64-pc-windows-msvc` (XP) |  ✓  |     |     | Windows XP support         |
| `x86_64-sun-solaris`          |  ✓  |  ✓  |     | 64-bit Solaris/SunOS       |
| `x86_64-unknown-bitrig`       |  ✓  |  ✓  |     | 64-bit Bitrig              |
| `x86_64-unknown-dragonfly`    |  ✓  |  ✓  |     | 64-bit DragonFlyBSD        |
| `x86_64-unknown-openbsd`      |  ✓  |  ✓  |     | 64-bit OpenBSD             |

注意，第三梯队的平台数目会随着时间不停增长，上表给出的只是部分较为典型的平台。

## 在Linux或Mac上安装

如果你所运行的是Linux或Mac系统，只需打开终端软件并输入以下指令即可：

```bash
$ curl -sSf https://static.rust-lang.org/rustup.sh | sh
```

这条指令会下载并执行一个脚本，该脚本负责了安装工作。如果一切顺利，你会看到如下输
出信息：

```text
Rust is ready to roll.
```

从这里开始，输入`y`代表'yes'，之后按照提示进行操作即可。

## 在Windows上安装

如果你使用的是Windows系统，请下载[安装包][install-page]。

[install-page]: https://www.rust-lang.org/install.html

## 卸载

卸载Rust同样非常简单。在Linux或者Mac系统上，执行以下指令即可：

```bash
$ sudo /usr/local/lib/rustlib/uninstall.sh
```

在Windows系统上，你可以重新运行`.msi`安装包，里面会给出卸载选项。

## 检查安装结果

完成安装后，打开终端并输入以下指令：

```bash
$ rustc --version
```

如果一切正常，你应该能够看到版本号、最近一次提交的hash值和日期。

能够看到以上信息就表明你已经成功的安装了Rust！恭喜你！

如果你没能看到以上信息并且你运行的Windows系统，请检查Rust是否被加入到了%PATH%环
境变量中：`$ echo %PATH%`。若没有则重新运行安装包并选择"Change"选项，确认“Add to
PATH”选项被选中。如果你想手动设置环境变量，Rust的可执行文件所在路径可能是
`"C:\Program Files\Rust stable GNU 1.x\bin"`。

Rust本身不负责链接工作，因此你需要确保系统中有可用的链接器。具体请查询文档。

如果还是看不到以上信息，你可以在下面几个地方寻求帮助。最容易的方式是通过
使用irc.mozilla.org上的两个irc聊天频道`#rust-beginners`和`#rust`。
你可通过[Mibbit网站][mibbit]提供的服务直接进入这些频道。在这些频道中你可以自由
的和其他Rustaceans（rust开发者的昵称）交流相关话题。其它可获取帮助的渠道还
有[Rust用户论坛][users]和[Stack Overflow网站][stackoverflow]。

[mibbit]: http://chat.mibbit.com/?server=irc.mozilla.org&channel=%23rust-beginners,%23rust
[users]: https://users.rust-lang.org/
[stackoverflow]: http://stackoverflow.com/questions/tagged/rust

Rust安装包在安装工具链和库的同时还会安装一份文档，因此我们可以离线查阅文档。在
UNIX系统上，`/usr/local/share/doc/rust`是安装文档的地址（译者注：如果是通过
rustup脚本安装的则可通过`$ rustup doc`命令打开文档）。在Windows系统上，文档被放
置在Rust安装目录下的`share/doc`目录。

# Hello, world!

完成了Rust的安装后，我们就可以开始写第一个Rust程序了。理所当然的，第一个程序的工
作就是向终端输出“Hello, world!”。

## 创建工程

首先，创建一个目录用于放置你的Rust代码。Rust本身不关心代码如何存放，但是在本文中
我们建议创建一个目录作为工程的根目录。打开终端并输入下列指令：

```bash
$ mkdir ~/projects
$ cd ~/projects
$ mkdir hello_world
$ cd hello_world
```

> 注意：如果你是在Windows系统中，建议使用PowerShell作为终端，否则`~`符号不能代表
> home目录。

## 编写程序

接下来就是创建一个文件并输入源码，文件命名为*main.rs*。Rust文件总是以*.rs*作为
结尾。如果你在文件名中使用了多个单词，应使用下划线将它们隔开。例如：你应该使用
*hello_world.rs*而不是*helloworld.rs*作为文件名。

下面就是我们的第一个Rust程序的源码：

```rust
fn main() {
    println!("Hello, world!");
}
```

保存好文件后返回终端，在UNIX系统上，输入以下指令：

```bash
$ rustc main.rs
$ ./main
Hello, world!
```

在Windows系统上，将`./main`替换为`main.exe`。无论是什么操作系统，最终你都会在
终端上看到字符串`Hello, world!`。至此，你已经完成了一个Rust程序，恭喜你！

## 程序剖析

现在，让我们分析一下源码，看看到底发生了什么。

```rust
fn main() {

}
```

以上三行代码的功能是定义了一个函数。和C/C++一样，`main`函数在Rust中有特殊的意义，
它被作为了整个程序的入口点，即程序是从main函数开始执行的。第一行代码声明了函数
的原型：函数名为`main`，没有入参也没有返回。在函数有入参的情况下，参数声明会被
放置在圆括号之中。由于main函数什么都不会返回，函数的返回部分是被忽略掉的。

整个函数体是被围绕在一对花括号之中的，这是Rust语法所要求的。将左花括号和函数声明
放置在同一行在Rust文化中被认为是不错的编码风格。

`main()`函数的实现：

```rust
    println!("Hello, world!");
```

这行代码实现了程序的所有功能：向终端输出字符串。有几点值得注意：1）程序以四个空
格作为缩进，而不是制表符；2）`println!`是对Rust宏的调用，这涉及到了Rust对元编程
的支持。如果我们是调用函数而不是宏，那么在调用符号的末尾不会有`!`符号。我们会在
后面的教程中详细描述Rust宏，现在你只需要知道`!`意味着对宏的调用即可。

接下来是`"Hello, world!"`字符串。字符串在系统编程语言中是个较为复杂的话题（相当
令人惊讶）。上面的代码使用了一个静态分配的字符串。我们将该字符串作为参数传递给了
`println!`，然后即可在屏幕上得到该字符串的输出。

上面的代码以分号作（`;`）为结尾。Rust是个以表达式为核心的语言，语言中的大部分元
素都是表达式。末尾的`;`意味着一个表达式已经结束，另一个可以开始了。Rust代码中的
大部分行都是以`;`作为结束符的。

## 编译和运行

在“编写程序”一节中，我们已经展示了如何运行新写的程序。现在我们将步骤拆分开逐个
进行分析。

在运行Rust程序之前，你首先需要将其进行编译。你可以使用Rust的编译器`rustc`，将源
文件作为编译器的输入接口，具体如下：

```bash
$ rustc main.rs
```

如果你具备C/C++的编程经验，你会发现这和`gcc`或`clang`的用法很类似。在编译成功后，
Rust会输出二进制文件，在UNIX系统上你可以通过在终端内输入`ls`命令将其列出：

```bash
$ ls
main  main.rs
```

在Windows系统上，你应该输入如下命令：

```bash
$ dir
main.exe
main.rs
```

由命令输出我们可以看到两个文件：源文件（以`.rs`结尾），二进制文件（Windows下是
`main.exe`，UNIX环境下是`main`）。接下来我们可以运行程序：

```bash
$ ./main  # or .\main.exe on Windows
```

如果*main.rs*是你的“Hello, world!”程序，终端上会输出`Hello, world!`。

如果你之前使用的是Ruby、Python或Javascript这样的动态语言，你可能会对先编译后运
行的做法感到不适应。Rust是一门*ahead-of-time compiled*语言，意为你可以将程序编译
好之后发送给其他人，而收到二进制程序的人可以直接将其运行而无需安装Rust。反之如果
你给了某人一个`.rb`、`py`或`js`文件，他需要在自己的电脑上先安装了Ruby、Python或
Javascript的某个实现后才能运行代码。

直接使用`rustc`编译源码对hello world这样的小程序来讲是足够了。但随着工程规模的
增长，你需要管理工程的各种选项，并且需要能方便的将你的代码共享给其他人或其它工
程。下面我们将为你介绍工具`Cargo`，它将会帮助你编写真正的rust程序。

# 你好Cargo！

Cargo是Rust的标准构建和包管理工具，基本上所有Rust工程都是由Cargo来管理的。Cargo
可管理三样东西：工程自身的源码、第三方依赖库的下载以及编译。

我们所编写的Rust程序不存在任何依赖，因此目前你还用不到Cargo的依赖项管理功能。随
着你编写的Rust程序越来越复杂，你会需要加入其它依赖项，使用Cargo会让这一切变得非
常简单。

随着越来越多的Rust工程开始使用Cargo，我们在接下来的教程中默认你也使用了Cargo作为
Rust工程的管理工具。Cargo工具默认属于Rust工具链的一部分，因此你只需安装官方的
Rust安装包即可。在终端内输入以下指令可检查Cargo工具是否可用：

```bash
$ cargo --version
```

## 转换工程

Let’s convert the Hello World program to Cargo. To Cargo-fy a project, you need
to do three things:

1. Put your source file in the right directory.
2. Get rid of the old executable (`main.exe` on Windows, `main` everywhere
   else).
3. Make a Cargo configuration file.

Let's get started!

### Creating a Source Directory and Removing the Old Executable

First, go back to your terminal, move to your *hello_world* directory, and
enter the following commands:

```bash
$ mkdir src
$ mv main.rs src/main.rs # or 'move main.rs src/main.rs' on Windows
$ rm main  # or 'del main.exe' on Windows
```

Cargo expects your source files to live inside a *src* directory, so do that
first. This leaves the top-level project directory (in this case,
*hello_world*) for READMEs, license information, and anything else not related
to your code. In this way, using Cargo helps you keep your projects nice and
tidy. There's a place for everything, and everything is in its place.

Now, move *main.rs* into the *src* directory, and delete the compiled file you
created with `rustc`. As usual, replace `main` with `main.exe` if you're on
Windows.

This example retains `main.rs` as the source filename because it's creating an
executable. If you wanted to make a library instead, you'd name the file
`lib.rs`. This convention is used by Cargo to successfully compile your
projects, but it can be overridden if you wish.

### Creating a Configuration File

Next, create a new file inside your *hello_world* directory, and call it
`Cargo.toml`.

Make sure to capitalize the `C` in `Cargo.toml`, or Cargo won't know what to do
with the configuration file.

This file is in the *[TOML]* (Tom's Obvious, Minimal Language) format. TOML is
similar to INI, but has some extra goodies, and is used as Cargo’s
configuration format.

[TOML]: https://github.com/toml-lang/toml

Inside this file, type the following information:

```toml
[package]

name = "hello_world"
version = "0.0.1"
authors = [ "Your name <you@example.com>" ]
```

The first line, `[package]`, indicates that the following statements are
configuring a package. As we add more information to this file, we’ll add other
sections, but for now, we only have the package configuration.

The other three lines set the three bits of configuration that Cargo needs to
know to compile your program: its name, what version it is, and who wrote it.

Once you've added this information to the *Cargo.toml* file, save it to finish
creating the configuration file.

## Building and Running a Cargo Project

With your *Cargo.toml* file in place in your project's root directory, you
should be ready to build and run your Hello World program! To do so, enter the
following commands:

```bash
$ cargo build
   Compiling hello_world v0.0.1 (file:///home/yourname/projects/hello_world)
$ ./target/debug/hello_world
Hello, world!
```

Bam! If all goes well, `Hello, world!` should print to the terminal once more.

You just built a project with `cargo build` and ran it with
`./target/debug/hello_world`, but you can actually do both in one step with
`cargo run` as follows:

```bash
$ cargo run
     Running `target/debug/hello_world`
Hello, world!
```

Notice that this example didn’t re-build the project. Cargo figured out that
the file hasn’t changed, and so it just ran the binary. If you'd modified your
source code, Cargo would have rebuilt the project before running it, and you
would have seen something like this:

```bash
$ cargo run
   Compiling hello_world v0.0.1 (file:///home/yourname/projects/hello_world)
     Running `target/debug/hello_world`
Hello, world!
```

Cargo checks to see if any of your project’s files have been modified, and only
rebuilds your project if they’ve changed since the last time you built it.

With simple projects, Cargo doesn't bring a whole lot over just using `rustc`,
but it will become useful in the future. This is especially true when you start
using crates; these are synonymous with a ‘library’ or ‘package’ in other
programming languages. For complex projects composed of multiple crates, it’s
much easier to let Cargo coordinate the build. Using Cargo, you can run `cargo
build`, and it should work the right way.

### Building for Release

When your project is ready for release, you can use `cargo build
--release` to compile your project with optimizations. These optimizations make
your Rust code run faster, but turning them on makes your program take longer
to compile. This is why there are two different profiles, one for development,
and one for building the final program you’ll give to a user.

### What Is That `Cargo.lock`?

Running `cargo build` also causes Cargo to create a new file called
*Cargo.lock*, which looks like this:

```toml
[root]
name = "hello_world"
version = "0.0.1"
```

Cargo uses the *Cargo.lock* file to keep track of dependencies in your
application. This is the Hello World project's *Cargo.lock* file. This project
doesn't have dependencies, so the file is a bit sparse. Realistically, you
won't ever need to touch this file yourself; just let Cargo handle it.

That’s it! If you've been following along, you should have successfully built
`hello_world` with Cargo.

Even though the project is simple, it now uses much of the real tooling you’ll
use for the rest of your Rust career. In fact, you can expect to start
virtually all Rust projects with some variation on the following commands:

```bash
$ git clone someurl.com/foo
$ cd foo
$ cargo build
```

## Making A New Cargo Project the Easy Way

You don’t have to go through that previous process every time you want to start
a new project! Cargo can quickly make a bare-bones project directory that you
can start developing in right away.

To start a new project with Cargo, enter `cargo new` at the command line:

```bash
$ cargo new hello_world --bin
```

This command passes `--bin` because the goal is to get straight to making an
executable application, as opposed to a library. Executables are often called
*binaries* (as in `/usr/bin`, if you’re on a Unix system).

Cargo has generated two files and one directory for us: a `Cargo.toml` and a
*src* directory with a *main.rs* file inside. These should look familiar,
they’re exactly what we created by hand, above.

This output is all you need to get started. First, open `Cargo.toml`. It should
look something like this:

```toml
[package]

name = "hello_world"
version = "0.1.0"
authors = ["Your Name <you@example.com>"]

[dependencies]
```

Do not worry about the `[dependencies]` line, we will come back to it later.

Cargo has populated *Cargo.toml* with reasonable defaults based on the arguments
you gave it and your `git` global configuration. You may notice that Cargo has
also initialized the `hello_world` directory as a `git` repository.

Here’s what should be in `src/main.rs`:

```rust
fn main() {
    println!("Hello, world!");
}
```

Cargo has generated a "Hello World!" for you, and you’re ready to start coding!

> Note: If you want to look at Cargo in more detail, check out the official [Cargo
guide], which covers all of its features.

[Cargo guide]: http://doc.crates.io/guide.html

# Closing Thoughts

This chapter covered the basics that will serve you well through the rest of
this book, and the rest of your time with Rust. Now that you’ve got the tools
down, we'll cover more about the Rust language itself.

You have two options: Dive into a project with ‘[Tutorial: Guessing Game][guessinggame]’, or
start from the bottom and work your way up with ‘[Syntax and
Semantics][syntax]’. More experienced systems programmers will probably prefer
‘Tutorial: Guessing Game’, while those from dynamic backgrounds may enjoy either. Different
people learn differently! Choose whatever’s right for you.

[guessinggame]: guessing-game.html
[syntax]: syntax-and-semantics.html
境变量中：`$ echo %PATH%`。若没有则重新运行安装包并选择“Change”
