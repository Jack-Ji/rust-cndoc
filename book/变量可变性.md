% 可变性

可变性表示一个变量是否可以被修改，Rust中的变量默认是不可变的：

```rust
let x = 5;
x = 6; // error!
```

我们可以通过`mut`声明一个可以被修改的变量：

```rust
let mut x = 5;

x = 6; // no problem!
```

上面代码中的`x`是个可变的变量绑定，因此修改它不会出任何问题。

你还可通过`&x`创建[引用][ref]，如果需要通过该引用修改变量则需创建可变引用：

```rust
let mut x = 5;
let y = &mut x;
```

[ref]: 引用和借用.md

上面的`y`是个指向可变变量的不可变引用，意思是你可以通过`y`修改`x`的的绑定值，但
不能够修改`y`自身。如果你需要`y`也能够被修改，可以这样实现：

```rust
let mut x = 5;
let mut y = &mut x;
```

`mut`是[模式][pattern]的一部分，这点非常重要，因为你可以做下面的事情：

```rust
let (mut x, y) = (5, 6);

fn foo(mut x: i32) {
# }
```

注意这里`x`可变，`y`不可变。

[pattern]: 模式.md

# 内部和外部可变性

在Rust中，当我们说一样东西是不可变时，我们并不是说这样东西是不可能变化的，我们说
的是它的外部可变性。具体请考虑类型[`Arc[T]`][arc]：

```rust
use std::sync::Arc;

let x = Arc::new(5);
let y = x.clone();
```

[arc]: https://doc.rust-lang.org/std/sync/struct.Arc.html

方法`clone()`会使`Arc[T]`增加内部引用计数，但是我们并未在变量`x`的前面添加`mut`，
因此变量`x`应该是不可变的，既然如此内部计数的修改是如何完成的呢？

要理解这段代码，我们需要回顾Rust的核心概念：[所有权][ownership]和[借用][borrowing]：

> 借用可以有下面两种情形，注意两种不能同时发生：
>
> * 多个不可变引用(`&T`)
> * 一个可变引用(`&mut T`).

[ownership]: 所有权.md
[borrowing]: 引用和借用.md

因此一个资源`不可变`的真正含义是：该资源能够安全的被两个指针同时指向。在本例中
`Arc[T]`就是这样的资源，其内部的可变性被完全隐藏了，对使用者是完全透明的。因此
上面的`clone()`方法返回的是`&T`类型，而不是`&mut T`，否则就违背了上面的借用原则！

标准库中的[`std::cell`][stdcell]类型则与`Arc[T]`相反，强调的是内部可变性。

```rust
use std::cell::RefCell;

let x = RefCell::new(42);

let y = x.borrow_mut();
```

[stdcell]: https://doc.rust-lang.org/std/cell/index.html

RefCell通过`borrow_mut()`方法返回的是`&mut`引用。也许有人要问了，这样岂不是很容
易违背借用原则吗，我只需要连续调用两次`borrow_mut()`方法就能创建两个`&mut`引用了，
就像如下代码：

```rust
use std::cell::RefCell;

let x = RefCell::new(42);

let y = x.borrow_mut();
let z = x.borrow_mut();
# (y, z);
```

以上代码的确可以编译通过，但是运行时会`panic`。`RefCell`的作用即在于此：它将借用
规则的分析从编译时延迟到了运行时，并在运行到违背原则的代码时`panic`。

## 内部成员的可变性

可变性是属于借用（`&mut`）和变量绑定（`let mut`）的属性，这意味着你不能使
[`struct`][struct]的某些成员是可变的，某些成员是不可变的。也就是说下面的代码是
不合法的：

```rust
struct Point {
    x: i32,
    mut y: i32, // nope
}
```

struct的可变性属于与其关联的变量绑定：

```rust
struct Point {
    x: i32,
    y: i32,
}

let mut a = Point { x: 5, y: 6 };

a.x = 10;

let b = Point { x: 5, y: 6};

b.x = 10; // error: cannot assign to immutable field `b.x`
```

[struct]: structs.html

通过使用[`Cell[T]`][cell]模块，你可以模拟成员的可变性：

```rust
use std::cell::Cell;

struct Point {
    x: i32,
    y: Cell<i32>,
}

let point = Point { x: 5, y: Cell::new(6) };

point.y.set(7);

println!("y: {:?}", point.y);
```

[cell]: https://doc.rust-lang.org/std/cell/struct.Cell.html
