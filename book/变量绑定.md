% 变量绑定

几乎所有的Rust程序都需要使用*变量绑定*，它的目的是将一个值与一个名称关联起来，
这样一来我们可以在程序中使用名称来访问值。`let`关键字就是用来创建一个新的绑定：

```rust
fn main() {
    let x = 5;
}
```

为减小篇幅，在后面的代码示例中我们将略去`fn main()`。

# 模式

在很多编程语言中，一个变量绑定通常被直接称为*变量*，这在Rust中有稍许不同，
其`let`语句的左侧部分实际上是个“[模式][pattern]”，不是个简单的变量名称。
这意味着我们可以做下面这样的事情：

```rust
let (x, y) = (1, 2);
```

这条语句的执行结果是`x`被绑定到值1，`y`被绑定到值2。模式非常强大，后面我们有
[单独的一章来描述它][pattern]。

[pattern]: patterns.md

# 类型声明

Rust是个静态类型语言，这意味着Rust中的变量类型是在编译时期确定和检查的。那么我们
的第一个示例是如何编译的呢？答案是Rust具备了一个现代语言特性：`类型推导`。Rust可
根据赋值表达式推导出变量的类型，因此无须你显式指定变量的类型。

当然，我们也可以在需要的时候显式声明变量的类型，其写法如下：

```rust
let x: i32 = 5;
```

你可以通过很自然的方式阅读该代码：`x`被绑定至一个`i32`类型的值`5`。

在本例中我们选择使用`x`表示一个32位整数。Rust支持很多不同的整数类型，以`i`打头
表示有符号整数，以`u`打头表示无符号整数，位宽有8、16、32和64位。

未来，我们会以注释的方式给出变量的具体类型：

```rust
fn main() {
    let x = 5; // x: i32
}
```

注意这个注释的内容与`let`的变量类型声明语法是一样的，这种注释方法在Rust中并不
常见，我们这样写是为了加深你的印象。

# 可变性 

在Rust中，变量绑定默认是不可变的。下面的代码编译会失败：

```rust
let x = 5;
x = 10;
```

编译这样的代码会出如下错误：

```text
error: re-assignment of immutable variable `x`
     x = 10;
     ^~~~~~~
```

如果你希望一个变量绑定是可变的，你需要使用`mut`关键字进行声明：

```rust
let mut x = 5; // mut x: i32
x = 10;
```

Rust默认变量绑定不可变的原因很显而易见——安全性，这是Rust主要关注的领域。如果你在
写代码时没有声明`mut`，编译器会捕捉修改变量的语句并给出错误，由此你能非常快的发
现变量的非法改动。如果确实需要改变变量，你必须显式的通过`mut`告诉编译器！

关于尽量保持变量的不变性还有很多话题（如函数式编程），但它们超出了本教程的内容。
总而言之，对变量的修改通常是可以避免的，保持变量的不变形在Rust编程范式中也同样
受到鼓励。尽管如此，你仍然可以在需要的时候对变量进行修改，这并不是被禁止的：）

# 变量绑定初始化

Rust的变量绑定必须被初始化，否则不允许被使用。让我们运行下面的代码试试看：

```rust
fn main() {
    let x: i32;

    println!("Hello world!");
}
```

输入`cargo build`命令后你会收到报警，然而"Hello, world!"仍然能够正常输出。

```text
   Compiling hello_world v0.0.1 (file:///home/you/projects/hello_world)
src/main.rs:2:9: 2:10 warning: unused variable: `x`, #[warn(unused_variables)]
   on by default
src/main.rs:2     let x: i32;
                      ^
```

Rust警告你变量`x`从未被使用过，因此尽管变量未被初始化，我们仍然可以正常运行程序。
下面让我们对程序做稍许改动：

```rust
fn main() {
    let x: i32;

    println!("The value of x is: {}", x);
}
```

再次运行就会看到错误了：

```bash
$ cargo build
   Compiling hello_world v0.0.1 (file:///home/you/projects/hello_world)
src/main.rs:4:39: 4:40 error: use of possibly uninitialized variable: `x`
src/main.rs:4     println!("The value of x is: {}", x);
                                                    ^
note: in expansion of format_args!
<std macros>:2:23: 2:77 note: expansion site
<std macros>:1:1: 3:2 note: in expansion of println!
src/main.rs:4:5: 4:42 note: expansion site
error: aborting due to previous error
Could not compile `hello_world`.
```

很显然Rust已经把原因讲得很清楚了，未初始化的变量是不能被使用的！

下面让我们分析一下`prinln!`语句：

首先，我们在格式字符串中添加了一对花括号`{}`，Rust会将其替换为后续传入的参数，
也就是`x`变量。

在使用花括号的情况下，Rust会自动根据变量类型选择合适的输出格式。如果你希望显式
指定输出格式，有[很多选项可以指定][format]。

[format]: https://doc.rust-lang.org/std/fmt/index.html

# 变量范围

Rust中的变量绑定是有有效范围的——即定义变量绑定的代码块（block）。一个代码块是指
围绕在一对花括号中的一系列语句。函数定义同样是个代码块。在下面的代码示例中，我们
定义了两个处于不同代码块中的变量绑定：`x`和`y`。变量`x`在代码块`fn main() {}`中
可被访问，`y`则只能在最小的代码块中被访问：

```rust
fn main() {
    let x: i32 = 17;
    {
        let y: i32 = 3;
        println!("The value of x is {} and value of y is {}", x, y);
    }
    println!("The value of x is {} and value of y is {}", x, y); // This won't work
}
```

聪明的你一定已经看出这段代码的问题所在了——变量`y`是不能被第二个`println!`语句使
用的。具体可见编译错误如下：

```bash
$ cargo build
   Compiling hello v0.1.0 (file:///home/you/projects/hello_world)
main.rs:7:62: 7:63 error: unresolved name `y`. Did you mean `x`? [E0425]
main.rs:7     println!("The value of x is {} and value of y is {}", x, y); // This won't work
                                                                       ^
note: in expansion of format_args!
<std macros>:2:25: 2:56 note: expansion site
<std macros>:1:1: 2:62 note: in expansion of print!
<std macros>:3:1: 3:54 note: expansion site
<std macros>:1:1: 3:58 note: in expansion of println!
main.rs:7:5: 7:65 note: expansion site
main.rs:7:62: 7:63 help: run `rustc --explain E0425` to see a detailed explanation
error: aborting due to previous error
Could not compile `hello`.

To learn more, run the command again with --verbose.
```

变量绑定的名称是可以重复使用的，后来定义的变量绑定会覆盖前面的。

```rust
let x: i32 = 8;
{
    println!("{}", x); // Prints "8"
    let x = 12;
    println!("{}", x); // Prints "12"
}
println!("{}", x); // Prints "8"
let x =  42;
println!("{}", x); // Prints "42"
```

变量绑定不止可以将变量名重新绑定至不同的变量，甚至还可以改变变量的可变性。注意变
量重新绑定不会导致原有的变量被修改或销毁，它们会一直存在，直到超出有效范围。

```rust
let mut x: i32 = 1;
x = 7;
let x = x; // x is now immutable and is bound to 7

let y = 4;
let y = "I can also be bound to text!"; // y is now of a different type
```
