% 引用和借用

本章是专门介绍Rust的所有权概念的三章中的第一章。所有权是Rust的最为重要和吸引人的
特性，Rust开发者需要对其非常熟悉。借助所有权，Rust实现了其最大的目标：内存安全。
本文将分以下三章对所有权进行详细介绍：

* [所有权核心概念][ownership]
* 引用和借用，你正在阅读本章：）
* [生命周期][lifetimes]

这三章以循序渐进的方式对Rust的所有权的相关概念进行了介绍，你需要理解全部三章内容
才能准确无误的使用所有权系统。

[ownership]: 所有权.md
[lifetimes]: 生命周期.md

# 前言

在我们深入学习所有权的细节之前，首先要对以下两点有所了解：

Rust是一门强调安全和速度的编程语言，为了达成本目标Rust语言的抽象概念一般是通过
编译时的分析完成的，因此Rust语言的大部分特性不会增加运行时的开支。本文提到的所
有分析过程都是这样实现的。

然而这样一来，Rust语言的学习曲线相比其它语言会显得有些陡峭——很多Rust开发者新
写的代码都有可能会因为违反了所有权系统的判定而导致代码编译不通过，这是因为开发者
的脑中还未能建立起正确的所有权系统模型。你无需对此过于担心，根据我们的调查，很多
Rust开发者会随着开发经验的增长越来越习惯所有权系统，进而写出有效的代码。

# 所有权的借用

在[所有权核心概念][ownership]一章的最后，我们给出了下面的代码：

```rust
fn foo(v1: Vec<i32>, v2: Vec<i32>) -> (Vec<i32>, Vec<i32>, i32) {
    // do stuff with v1 and v2

    // hand back ownership, and the result of our function
    (v1, v2, 42)
}

let v1 = vec![1, 2, 3];
let v2 = vec![1, 2, 3];

let (v1, v2, answer) = foo(v1, v2);
```

很明显，为了将向量v1、v2的所有权交还回来，函数foo的代码写得非常的丑陋。实际上我
们可以通过`借用`所有权的方式优化以上代码：

```rust
fn foo(v1: &Vec<i32>, v2: &Vec<i32>) -> i32 {
    // do stuff with v1 and v2

    // return the answer
    42
}

let v1 = vec![1, 2, 3];
let v2 = vec![1, 2, 3];

let answer = foo(&v1, &v2);

// we can use v1 and v2 here!
```

这下代码清爽多了吧！下面是一段稍微复杂点的代码：

```rust
fn main() {
    // Don't worry if you don't understand how `fold` works, the point here is that an immutable reference is borrowed.
    fn sum_vec(v: &Vec<i32>) -> i32 {
        return v.iter().fold(0, |a, &b| a + b);
    }
    // Borrow two vectors and sum them.
    // This kind of borrowing does not allow mutation to the borrowed.
    fn foo(v1: &Vec<i32>, v2: &Vec<i32>) -> i32 {
        // do stuff with v1 and v2
        let s1 = sum_vec(v1);
        let s2 = sum_vec(v2);
        // return the answer
        s1 + s2
    }

    let v1 = vec![1, 2, 3];
    let v2 = vec![4, 5, 6];

    let answer = foo(&v1, &v2);
    println!("{}", answer);
}
```

可以看到上面代码中函数的参数类型是`&Vec<i32>`，那么多出来的`&`符号意味着什么呢？
在Rust中我们称`&T`这样的类型为引用，这种类型的变量不会完全“夺取”资源的所有权，而
是借用，借用意味着当引用超出了其有效范围后资源不会被释放掉。因此我们可以在调用过
`foo()`函数之后继续使用以前的变量：）

引用默认是不可变的，这意味着在函数`foo()`中参数v不可以被修改：

```rust
fn foo(v: &Vec<i32>) {
     v.push(5);
}

let v = vec![];

foo(&v);
```

编译以上代码会得到如下错误信息：

```text
error: cannot borrow immutable borrowed content `*v` as mutable
v.push(5);
^
```

# 可变引用

另外还有一种可以修改的引用类型：`&mut T`，实例代码如下：

```rust
let mut x = 5;
{
    let y = &mut x;
    *y += 1;
}
println!("{}", x);
```

以上代码会输出`6`，这是因为我们创建了一个指向`x`的可变引用`y`，且将其加1。需要注
意的是变量`x`被标注为`mut`，即可以修改，否则我们相当于在修改一个常量，这明显是
不合法的。

注意我们需要在引用`y`的前面添加星号`*`才能访问引用所指向的内容。

另外需要注意的是上面代码中的引用y必须在单独的块区域中声明，否则会发生如下错误：

```text
error: cannot borrow `x` as immutable because it is also borrowed as mutable
    println!("{}", x);
                   ^
note: previous borrow of `x` occurs here; the mutable borrow prevents
subsequent moves, borrows, or modification of `x` until the borrow ends
        let y = &mut x;
                     ^
note: previous borrow ends here
fn main() {

}
^
```

可以看到，引用是有一定规则的。

# 引用的规则

以下就是引用的两大规则：
1）引用的有效范围不能超过资源所有者的有效范围；
2）对一个资源可创建多个不可变引用（&T）或者一个可变引用（&mut T），注意两种情况
不允许同时发生；

你也许注意到了，以上描述与数据竞争有些类似：
> 两个指针同时指向同一块数据；
> 通过两个指针对数据进行并行改动和读取；

可以对同一个资源创建多个不可变引用，因为并行读取数据是不会有任何问题的。此外限制
对一个资源只能创建一个可变引用也消除了数据竞争产生的条件。上述检查都是在编译时完
成的，如果我们的代码违背了上述原则编译会出错。

## 借用范围

考虑如下代码：

```rust
fn main() {
    let mut x = 5;
    let y = &mut x;

    *y += 1;

    println!("{}", x);
}
```

编译上面的代码会得到如下错误信息：

```text
error: cannot borrow `x` as immutable because it is also borrowed as mutable
    println!("{}", x);
                   ^
```

这是因为我们违背了上述的引用原则：我们已经为`x`创建了一个`&mut T`类型的引用，因此
在`println!()`中再次创建`&T`引用是非法的。Rust会提示我们上一次的借用什么时候才会
失效：

```text
note: previous borrow ends here
fn main() {

}
^
```

根据提示可以看出，我们创建的`&mut T`引用一直到程序结束才会失效。我们希望这个引用
能够及时失效，这样资源的所有权才能被顺利的转移回`x`，从而最终在`println!`中提供
`&T`类型的引用。在Rust中，借用总是和其有效范围紧密关联的，下面代码的注释中标注了
借用的有效范围：

```rust
fn main() {
    let mut x = 5;

    let y = &mut x;    // -+ &mut borrow of x starts here
                       //  |
    *y += 1;           //  |
                       //  |
    println!("{}", x); // -+ - try to borrow x here
}                      // -+ &mut borrow of x ends here
                       
```

显然有效范围冲突了：我们不能在`y`未失效的情况下创建`&x`。

基于上述原因，我们引入了代码块：

```rust
let mut x = 5;

{
    let y = &mut x; // -+ &mut borrow starts here
    *y += 1;        //  |
}                   // -+ ... and ends here

println!("{}", x);  // <- try to borrow x here
```

这样一来就没问题了，可变引用y在代码块的结尾会失效，借用范围的冲突消失了。

## 借用解决了什么？

借用解决的关键问题是数据竞争。以下是数据竞争的例子：

### 非法迭代

第一个例子是‘非法迭代’，即在迭代数据的过程中对数据进行修改。Rust会禁止这类操作：

```rust
let mut v = vec![1, 2, 3];

for i in &v {
    println!("{}", i);
}
```

以上代码输出数字1-3。在迭代向量的过程中，我们会依次得到向量各个元素的引用，同时
向量v本身也被以不可变的方式借用了，这意味着我们在迭代过程中不能修改向量！

```rust
let mut v = vec![1, 2, 3];

for i in &v {
    println!("{}", i);
    v.push(34);
}
```

上面的代码在遍历向量的过程中尝试修改向量，编译错误如下：

```text
error: cannot borrow `v` as mutable because it is also borrowed as immutable
    v.push(34);
    ^
note: previous borrow of `v` occurs here; the immutable borrow prevents
subsequent moves or mutable borrows of `v` until the borrow ends
for i in &v {
          ^
note: previous borrow ends here
for i in &v {
    println!(“{}”, i);
    v.push(34);
}
^
```

我们不能修改向量v，因为它被整个循环体借用了。

### 释放后使用

引用的有效范围不能超过资源本身，Rust的编译时检查会保证这一点，否则我们可能会使用
一个已经失效的引用：

```rust
let y: &i32;
{
    let x = 5;
    y = &x;
}

println!("{}", y);
```
编译上面的代码会出现下面的错误：

```text
error: `x` does not live long enough
    y = &x;
         ^
note: reference must be valid for the block suffix following statement 0 at
2:16...
let y: &i32;
{
    let x = 5;
    y = &x;
}

note: ...but borrowed value is only valid for the block suffix following
statement 0 at 4:18
    let x = 5;
    y = &x;
}
```

换句话说，引用y仅在x有效的范围内才是有效的，一旦超出了x的有效范围，引用y就不再
有效。因此Rust在错误信息中特意说明了引用的资源‘doesn’t live long enough’。

除此以外还有个问题，那就是引用声明在前，引用的变量声明在后：

```rust
let y: &i32;
let x = 5;
y = &x;

println!("{}", y);
```

编译上面的代码或得到如下错误：

```text
error: `x` does not live long enough
y = &x;
     ^
note: reference must be valid for the block suffix following statement 0 at
2:16...
    let y: &i32;
    let x = 5;
    y = &x;

    println!("{}", y);
}

note: ...but borrowed value is only valid for the block suffix following
statement 1 at 3:14
    let x = 5;
    y = &x;

    println!("{}", y);
}
```

原因与之前类似，引用y的有效期超过了x。
