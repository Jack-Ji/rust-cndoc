% 结构体

结构体（`struct`）可以用于创建复杂的数据结构。假如我们需要处理二维空间的坐标，我
们需要`x`和`y`两个坐标值：

```rust
let origin_x = 0;
let origin_y = 0;
```

使用结构体我们可以将两个值包含到一个数据结构中：

```rust
struct Point {
    x: i32,
    y: i32,
}

fn main() {
    let origin = Point { x: 0, y: 0 }; // origin: Point

    println!("The origin is at ({}, {})", origin.x, origin.y);
}
```

这里我们通过`struct`关键字创建了一个结构体`Point`。传统上，结构体的名称采用驼峰
式命名法。

通过`let`我们可以创建一个`struct`实例，并且使用`key:value`的方式初始化其成员，成
员初始化的顺序可以与结构体定义中的顺序不同。

最后，我们可通过`.`符号访问实例的成员：`origin.x`。

和Rust中的变量绑定一样，`struct`的成员默认也是不可变的，可以使用`mut`使其可变：

```rust
struct Point {
    x: i32,
    y: i32,
}

fn main() {
    let mut point = Point { x: 0, y: 0 };

    point.x = 5;

    println!("The point is at ({}, {})", point.x, point.y);
}
```

以上代码的输出是：`The point is at (5, 0)`。

Rust在语法层面是不支持对成员的可变性进行设置的，因此以下代码是非法的：

```rust
struct Point {
    mut x: i32,
    y: i32,
}
```

如上一章所述，可变性是变量绑定的属性。这样的做法一开始可能有些奇怪，实际上它大大
简化了代码的编写。你甚至可以临时改变成员的可变性：

```rust
struct Point {
    x: i32,
    y: i32,
}

fn main() {
    let mut point = Point { x: 0, y: 0 };

    point.x = 5;

    let point = point; // now immutable

    point.y = 6; // this causes an error
}
```

结构体中仍然可以包含`&mut`类型的引用，通过该引用你可以修改其指向的资源：

```rust
struct Point {
    x: i32,
    y: i32,
}

struct PointRef<'a> {
    x: &'a mut i32,
    y: &'a mut i32,
}

fn main() {
    let mut point = Point { x: 0, y: 0 };

    {
        let r = PointRef { x: &mut point.x, y: &mut point.y };

        *r.x = 5;
        *r.y = 6;
    }

    assert_eq!(5, point.x);
    assert_eq!(6, point.y);
}
```

# 覆盖语法

一个结构体可以通过使用`..`操作符达到拷贝另一个结构体的成员数据的目的：

```rust
struct Point3d {
    x: i32,
    y: i32,
    z: i32,
}

let mut point = Point3d { x: 0, y: 0, z: 0 };
point = Point3d { y: 1, .. point };
```

```rust
# struct Point3d {
#     x: i32,
#     y: i32,
#     z: i32,
# }
let origin = Point3d { x: 0, y: 0, z: 0 };
let point = Point3d { z: 1, x: 2, .. origin };
```

# 元结构体

Rust还支持另一种介于[元组][tuple]和结构体之间的一种类型结构，我们称之为元结构体。
元结构体的成员没有名称，且使用`()`包围其定义：

[tuple]: 基本类型.md

```rust
struct Color(i32, i32, i32);
struct Point(i32, i32, i32);

let black = Color(0, 0, 0);
let origin = Point(0, 0, 0);
```

上面代码中的`black`和`origin`不是同一类型，尽管它们的结构是一样的。

和元组一样，原结构体同样可使用`.`符号访问其成员，并且可通过`let`对其进行拆分：

```rust
# struct Color(i32, i32, i32);
# struct Point(i32, i32, i32);
# let black = Color(0, 0, 0);
# let origin = Point(0, 0, 0);
let black_r = black.0;
let Point(_, origin_y, origin_z) = origin;
```

模式`Point(_, origin_y, origin_z)`同样可用于[match][match]。

一种常见的元结构体用法是只包含一个成员，这样一来我们相当于基于该成员实现了一个新
的数据类型：

```rust
struct Inches(i32);

let length = Inches(10);

let Inches(integer_length) = length;
println!("length is {} inches", integer_length);
```

上面的代码使用模式提取了原结构中成员的值，我们还可以通过`.`操作符实现该目的：

```rust
# struct Inches(i32);
# let length = Inches(10);
let integer_length = length.0;
```

元结构体一般总是能够被结构体所替代，并且常常会使代码看起来更加清晰：

```rust
struct Color {
    red: i32,
    blue: i32,
    green: i32,
}

struct Point {
    x: i32,
    y: i32,
    z: i32,
}
```

[match]: match.md

# 单元结构体

单元结构体即是没有成员的结构：

```rust
struct Electron {} // use empty braces...
struct Proton;     // ...or just a semicolon

// whether you declared the struct with braces or not, do the same when creating one
let x = Electron {};
let y = Proton;
```

单元结构体一般很少单独使用。最常见的用法是将单元结构体作为某个[trait][trait]定义
的载体。

[trait]: traits.md
