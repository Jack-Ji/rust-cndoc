% 所有权

本章是专门介绍Rust的所有权概念的三章中的第一章。所有权是Rust的最为重要和吸引人的
特性，Rust开发者需要对其非常熟悉。借助所有权，Rust实现了其最大的目标：内存安全。
本文将分以下三章对所有权进行详细介绍：

* 所有权核心概念，你正在阅读本章：）
* [引用借用][borrowing]
* [生命周期][lifetimes]

这三章以循序渐进的方式对Rust的所有权的相关概念进行了介绍，你需要理解全部三章内容
才能准确无误的使用所有权系统。

[borrowing]: 引用和借用.md
[lifetimes]: 生命周期.md

# 前言

在我们深入学习所有权的细节之前，首先要对以下两点有所了解：

Rust是一门强调安全和速度的编程语言，为了达成本目标Rust语言的抽象概念一般是通过
编译时的分析完成的，因此Rust语言的大部分特性不会增加运行时的开支。本文提到的所
有分析过程都是这样实现的。

然而这样一来，Rust语言的学习曲线相比其它语言会显得有些陡峭——很多Rust开发者新
写的代码都有可能会因为违反了所有权系统的判定而导致代码编译不通过，这是因为开发者
的脑中还未能建立起正确的所有权系统模型。你无需对此过于担心，根据我们的调查，很多
Rust开发者会随着开发经验的增长越来越习惯所有权系统，进而写出有效的代码。

# 所有权

Rust中的[变量绑定][bindings]具备一个特性：绑定的变量`拥有`被绑定的`元素或值`。这
意味着一旦一个变量绑定超出了其有效范围，Rust会释放变量所占用的资源。例如：

```rust
fn foo() {
    let v = vec![1, 2, 3];
}
```

以上代码中的向量v是位于[栈][stack]上面的，此外向量v还需从[堆][heap]中分配内存用
于放置向量的元素。当变量`v`超出了其有效范围（即foo函数）时，Rust会释放其占用的
堆和栈上的所有内存。

[heap]: 堆与栈.md
[stack]: 堆与栈.md
[bindings]: 变量绑定.md

# 所有权的转移

Rust规定了资源的所有权只能属于一个变量。假如你有一个向量，你可以将它的所有权移交
给另一个变量：

```rust
let v = vec![1, 2, 3];

let v2 = v;
```

如果我们在以上代码的后面使用`v`变量，Rust会报错：

```rust
let v = vec![1, 2, 3];

let v2 = v;

println!("v[0] is: {}", v[0]);
```

错误信息如下：

```text
error: use of moved value: `v`
println!("v[0] is: {}", v[0]);
                        ^
```

如果一个函数将参数的所有权获取了，在函数调用完毕后接着使用之前传入的实参也是不合
法的：

```rust
fn take(v: Vec<i32>) {
    // what happens here isn’t important.
}

let v = vec![1, 2, 3];

take(v);

println!("v[0] is: {}", v[0]);
```

以上错误的原因都是一样的：'use of moved value'。当所有权被移交时，我们一般称之为
`移动`了某个资源。移动资源是Rust的默认行为，不需要特殊的语法。

## 细节

下面解释一下为何一个变量绑定被移动过后就不能再被使用了，首先请看如下代码：

```rust
let x = 10;
```

在以上代码中，Rust在[栈][sh]上分配了一个整数[i32]，将值初始化为10，并将变量名x
关联到这块内存。

[i32]: 基本类型.md

继续考虑如下代码：

```rust
let v = vec![1, 2, 3];

let mut v2 = v;
```

第一行代码在栈上为向量对象v分配了内存，这一点与上面的整数变量`x`相同。除此之外，
第一行代码还从[堆][sh]中为向量v的真正数据（`[1, 2, 3]`）分配了内存，栈上表示向量
v的对象中保存了该内存地址。

你应该注意到了，表示向量的内存被分为两部分：栈上的向量对象和堆中的向量数据。

当我们将变量`v`移动至`v2`时，Rust仅仅将向量对象v的栈内存拷贝至了向量对象v2的栈
内存，这样一来就免除了对向量数据的拷贝。不难发现此时我们可以通过两个变量同时访问
向量数据，这很容易导致数据的不一致访问，很明显这违背了Rust的安全宗旨。举例来讲，
假如我们通过变量v2截断了向量数据，向量v无从得知这个情况，这样一来就有可能通过
向量v去访问非法内存地址！

```rust
# let v = vec![1, 2, 3];
# let mut v2 = v;
v2.truncate(2);
```

基于以上原因，Rust禁止了对移动过的变量v继续使用（注意该分析都是在编译时完成的）。

[sh]: 堆与栈.md

另外需要注意的是Rust会对所有权的转移进行优化，优化的结果可能是被移动的变量的栈
内存被回收掉，因此所有权的转移并不会像你所想象的那么低效。

## `Copy`类型

我们已经知道了变量在所有权被转移以后就不能再被继续使用了。然而，我们可以通过[trait][traits]
改变这种行为，这个trait就是`Copy`。我们还没有正式介绍过trait，你可以将它看成是为
某个类型添加新行为的手段。

```rust
let v = 1;

let v2 = v;

println!("v is: {}", v);
```

在上面的代码中，变量`v`的类型是`i32`，该类型实现了`Copy trait`。这意味着当使用
该类型的变量进行赋值操作时，我们会得到一份原数据的拷贝，原来的数据不会被回收。因
此在上面的代码中，变量v在经过一次赋值后仍然可以被使用。

Rust中的基本类型都实现了`Copy trait`，它们的所有权都不会被转移，以下代码都是
合法的：

```rust
fn main() {
    let a = 5;

    let _y = double(a);
    println!("{}", a);
}

fn double(x: i32) -> i32 {
    x * 2
}
```

```rust
fn main() {
    let a = true;

    let _y = change_truth(a);
    println!("{}", a);
}

fn change_truth(x: bool) -> bool {
    !x
}
```

如果变量a的类型没有实现`Copy trait`，我们会得到如下错误：

```text
error: use of moved value: `a`
println!("{}", a);
               ^
```

在后面的[traits章节][traits]中，我们会教你如何为自己的类型实现`Copy trait`。

[traits]: traits.md

# 所有权带来的问题

如果我们希望一个没有实现`Copy trait`的变量在被作为参数传递给函数后仍然可以继续
使用，我们需要按照下面的方式定义函数：

```rust
fn foo(v: Vec<i32>) -> Vec<i32> {
    // do stuff with v

    // hand back ownership
    v
}
```

```rust
fn foo(v1: Vec<i32>, v2: Vec<i32>) -> (Vec<i32>, Vec<i32>, i32) {
    // do stuff with v1 and v2

    // hand back ownership, and the result of our function
    (v1, v2, 42)
}

let v1 = vec![1, 2, 3];
let v2 = vec![1, 2, 3];

let (v1, v2, answer) = foo(v1, v2);
```

很显然这样写太麻烦了！

请放心，Rust的设计者们早就考虑到了这一点，我们将在下一章讨论`所有权的借用`。

