% 向量（`vector`）

与C/C++中的vector类似，Rust中的向量（`vector`）是可以动态增长的数组。它是标准
库中提供的类型[`Vec<T>`][vec]，其中`T`代表向量可以包含任何类型，具体参见[泛型][generic]。
向量使用的内存总是从堆上分配的。创建向量可使用宏`vec!`：

```rust
let v = vec![1, 2, 3, 4, 5]; // v: Vec<i32>
```

注意与我们之前使用宏`println!`的方式不同，这里使用了`[]`包围参数而不是`()`。
Rust允许你使用两种方式均可，这里使用`[]`只是惯例。

宏`vec!`还支持指定单个元素值和长度的语法，使用该语法可以很方便的创建一个元素全都
一样的向量：

```rust
let v = vec![0; 10]; // ten zeroes
```

由于向量需要分配连续内存来存放类型为`T`的数组，Rust必须在编译时确定类型`T`所占用
的内存大小。然而有些数据的大小在编译时是无法确定的，对这些数据我们只能保存指向其
的指针，标准库提供的[`Box`][box]类型即可用于该目的。

## 访问向量元素

访问向量元素的语法与数组类似，都是使用`[]`来给出数组下标（从0开始）：

```rust
let v = vec![1, 2, 3, 4, 5];

println!("The third element of v is {}", v[2]);
```

此外还需要注意向量下标值的类型必须是`usize`：

```rust
let v = vec![1, 2, 3, 4, 5];

let i: usize = 0;
let j: i32 = 0;

// works
v[i];

// doesn’t
v[j];
```

使用`usize`以外的类型会导致如下错误：

```text
error: the trait bound `collections::vec::Vec<_> : core::ops::Index<i32>`
is not satisfied [E0277]
v[j];
^~~~
note: the type `collections::vec::Vec<_>` cannot be indexed by `i32`
error: aborting due to previous error
```

## 越界访问

越界访问向量会导致程序`panic`：

```rust
let v = vec![1, 2, 3];
println!("Item 7 is {}", v[7]);
```

```text
thread 'main' panicked at 'index out of bounds: the len is 3 but the index is 7'
```

如果你需要自己处理数组越界错误，可以使用向量的[`get`][get]或[`get_mut`][get_mut]
方法，这两个方法在下标不合法的情况下会返回`None`：

```rust
let v = vec![1, 2, 3];
match v.get(7) {
    Some(x) => println!("Item 7 is {}", x),
    None => println!("Sorry, this vector is too short.")
}
```

## 迭代

可以使用`for`语法便利向量的所有元素，以下是三种方式：

```rust
let mut v = vec![1, 2, 3, 4, 5];

for i in &v {
    println!("A reference to {}", i);
}

for i in &mut v {
    println!("A mutable reference to {}", i);
}

for i in v {
    println!("Take ownership of the vector and its element {}", i);
}
```

注意，第三种遍历方式会导致向量的所有权被转让，因此遍历结束后向量不能再被使用，
前两种方式则没有没有限制。由于此原因，下面的代码是不能运行的：

```rust
let v = vec![1, 2, 3, 4, 5];

for i in v {
    println!("Take ownership of the vector and its element {}", i);
}

for i in v {
    println!("Take ownership of the vector and its element {}", i);
}
```

下面的代码则使用了引用方式遍历向量，是可以运行的:

```rust
let v = vec![1, 2, 3, 4, 5];

for i in &v {
    println!("This is a reference to {}", i);
}

for i in &v {
    println!("This is a reference to {}", i);
}
```

向量还有很多其它有用的方法和接口，具体请参阅[标准库文档][vec]。

[vec]: https://doc.rust-lang.org/std/vec/index.html
[box]: https://doc.rust-lang.org/std/boxed/index.html
[generic]: 泛型.md
[get]: https://doc.rust-lang.org/std/vec/struct.Vec.html#method.get
[get_mut]: https://doc.rust-lang.org/std/vec/struct.Vec.html#method.get_mut
