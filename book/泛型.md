% 泛型

在实现一个函数或结构体时，我们可能需要其适应各种不同类型。是的，这就是应用
泛型的地方。

Rust标准库提供的`Option<T>`就是一个泛型类型：

```rust
enum Option<T> {
    Some(T),
    None,
}
```

上面代码中的`<T>`表明了这是一个泛型数据类型。在枚举内部出现`T`的地方都会被替换成
具体的数据类型。下面是示例：

```rust
let x: Option<i32> = Some(5);
```

`Option<i32>`告诉我们`Option`中的`T`的类型为`i32`，因此在右侧我们传递了`5`作为
`Some()`的参数。如果我们传递给`Some()`的值和类型声明不一致，Rust会报错：

```rust
let x: Option<f64> = Some(5);
// error: mismatched types: expected `core::option::Option<f64>`,
// found `core::option::Option<_>` (expected f64 but found integral variable)
```

以下是正确的示例：

```rust
let x: Option<i32> = Some(5);
let y: Option<f64> = Some(5.0f64);
```

泛型参数可以有多个，例如：

```rust
enum Result<T, E> {
    Ok(T),
    Err(E),
}
```

顺带一提，表示泛型参数的大写字母可以是任意的，例如：

```rust
enum Result<A, Z> {
    Ok(A),
    Err(Z),
}
```

一般我们用`T`表示类型，`E`表示错误，尽管Rust并不在乎。

`Result<T, E>`用于返回计算结果，如果成功则包含计算值，失败则包含错误信息。

## 泛型函数

泛型函数的定义与上面给出的例子类似：

```rust
fn takes_anything<T>(x: T) {
    // do something with x
}
```

`<T>`表明函数接受一个泛型参数，`x: T`则表明`x`的类型为`T`。

函数多个参数可以是相同的泛型类型：

```rust
fn takes_two_of_the_same_things<T>(x: T, y: T) {
    // ...
}
```

以下是多个泛型参数的示例：

```rust
fn takes_two_things<T, U>(x: T, y: U) {
    // ...
}
```

## 泛型结构体

结构体同样也可以具备泛型参数：

```rust
struct Point<T> {
    x: T,
    y: T,
}

let int_origin = Point { x: 0, y: 0 };
let float_origin = Point { x: 0.0, y: 0.0 };
```

与函数类似，`<T>`用于声明我们的泛型参数，`x: T`则表明了成员的泛型类型。

在为泛型结构体添加方法时，需要在`impl`后面声明泛型参数：

```rust
# struct Point<T> {
#     x: T,
#     y: T,
# }
#
impl<T> Point<T> {
    fn swap(&mut self) {
        std::mem::swap(&mut self.x, &mut self.y);
    }
}
```

泛型参数可以接受任何类型，`Option<T>`和`Result<T, E>`都是这样的例子。然而有时我
们也希望能够限制类型的范围，我们可以进一步学习[trait][traits]来理解为什么和如何
达到这个目的。

[traits]: traits.md
