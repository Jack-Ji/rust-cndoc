% 函数

和C/C++类似，每个Rust程序至少有一个函数：`main`函数：

```rust
fn main() {
}
```

以上就是Rust中最简单的函数定义形式。`fn`表示函数定义的开始，接下来是函数的名字，
然后是一对圆括号括起来的函数形参的声明，最后是一对花括号括起来的函数体。下面是
函数`foo`的定义形式：

```rust
fn foo() {
}
```

下面的函数接受一个参数，该函数会将参数打印到终端：

```rust
fn print_number(x: i32) {
    println!("x is: {}", x);
}
```

下面是对`print_number`函数进行调用的代码：

```rust
fn main() {
    print_number(5);
}

fn print_number(x: i32) {
    println!("x is: {}", x);
}
```

可以看出，函数参数的写法与`let`语句类似：参数的类型是在冒号后面指定的。

下面的代码将两个整数相加并将结果打印出来：

```rust
fn main() {
    print_sum(5, 6);
}

fn print_sum(x: i32, y: i32) {
    println!("sum is: {}", x + y);
}
```

通过以上代码可看出，函数的多个参数用逗号隔开。

和`let`不一样，函数参数的类型无法被自动推导出来，而是必须显式指定。

```rust
fn print_sum(x, y) {
    println!("sum is: {}", x + y);
}
```

编译以上代码会给出如下错误信息： 

```text
expected one of `!`, `:`, or `@`, found `)`
fn print_sum(x, y) {
```

这是Rust有意设计的结果。实际上函数自动推导参数类型在技术上是可行的，Haskell语言
就具备该特性。然而Haskell也要求程序员在函数注释中尽量说明函数支持的参数类型。
我们认为Rust在函数参数中显式指定类型，在函数体中自动推导变量类型是个较为适宜的
设计决策。

那么函数如何返回值呢？下面的函数返回一个整数值：

```rust
fn add_one(x: i32) -> i32 {
    x + 1
}
```

Rust函数只能返回一个值，返回值的类型在箭头（`->`）后面声明。函数的最后一行决定了
返回的值，注意分号是我们故意忽略掉的。如果加上分号，程序的编译会出错：

```rust
fn add_one(x: i32) -> i32 {
    x + 1;
}
```

```text
error: not all control paths return a value
fn add_one(x: i32) -> i32 {
     x + 1;
}

help: consider removing this semicolon:
     x + 1;
          ^
```

这揭示了Rust中两个有趣的事实：1）Rust是个以表达式为基础的语言；2）没有以分号结尾
的语句会返回一个值。这一点跟C/C++、Java语言都不同相同。

## 表达式vs语句

正如上所述，Rust的大部分语言结构都是基于表达式的，除了`声明语句`和`表达式语句`
以外全都是表达式。那么表达式和语句的区别是什么呢？表达式会返回一个值，而语句则
不会。下面我们首先讨论声明语句：

在有些编程语言中，变量绑定可以被当做为表达式返回一个值，如Ruby：

```ruby
x = y = 5
```

然而在Rust中，`let`语句不是一个表达式，因此下面这样的代码是错误的：

```rust
let x = (let y = 5); // expected identifier, found keyword `let`
```

编译器会告诉我们`let`语句只能表示一个语句，不能表示表达式。

尽管用处不大，仍然需要注意简单的赋值语句（如`y = 5`）仍然是个表达式。与其他编程
语言不同，Rust的赋值语句的返回值不是所赋的值，而是一个空元组`()`，这是因为Rust
的赋值语句中所赋的值具备[所有权](所有权.md)。

```rust
let mut y = 5;

let x = (y = 6);  // x has the value `()`, not `6`
```

Rust中的第二类语句是*表达式语句*，它的意义在于可以将任何表达式转换成语句。从实际
意义上讲，Rust的语法规定了程序的结构是多条语句的组合，因此我们需要使用分号将程序
的多个表达式转换为语句。这意味着Rust的程序看起来与C/C++、Java等非常类似——大部分
代码行都需要以分号作为结尾。那么为何还有小部分代码不需要以分号作为结尾呢？事实上
你已经见到了这样的代码了：

```rust
fn add_one(x: i32) -> i32 {
    x + 1
}
```

由于我们的函数返回类型是`i32`，我们不能在函数体的表达式`x + 1`后面添加分号，否则
该语句的返回值会变成`()`。Rust能够在编译期间检查出这种错误，它会在错误信息中建议
将分号去掉。

## 函数提早返回

Rust有个关键字`return`可用于提早从函数返回：

```rust
fn foo(x: i32) -> i32 {
    return x;

    // we never run this code!
    x + 1
}
```

在函数的最后一行可以使用`return`语句返回某个值，虽然这通常被认为是不符合Rust编程
风格的做法。

```rust
fn foo(x: i32) -> i32 {
    return x + 1;
}
```

对新手来讲，不使用return语句从函数返回可能会显得比较奇怪，随着Rust编程经验的增
加，这样的写法会逐渐变得自然起来。

## 偏函数

Rust有个特殊的函数种类，该函数永远不会返回，名为`偏函数`。

```rust
fn diverges() -> ! {
    panic!("This function never returns!");
}
```

`panic!`是个宏，与我们之前使用过的`println!`一样。`panic!`的作用是使当前执行线程
崩溃并给出相应信息。上面的函数总是会导致程序崩溃，它的类型为`!`，即用于表示当前
定义的函数是个偏函数。

如果在`main`函数中调用了上面的`diverges`函数，你会得到如下的崩溃信息：

```text
thread ‘main’ panicked at ‘This function never returns!’, hello.rs:2
```

如果你希望得到更多的信息，可以通过使用环境变量`RUST_BACKTRACE`输出调用栈：

```text
$ RUST_BACKTRACE=1 ./diverges
thread 'main' panicked at 'This function never returns!', hello.rs:2
stack backtrace:
   1:     0x7f402773a829 - sys::backtrace::write::h0942de78b6c02817K8r
   2:     0x7f402773d7fc - panicking::on_panic::h3f23f9d0b5f4c91bu9w
   3:     0x7f402773960e - rt::unwind::begin_unwind_inner::h2844b8c5e81e79558Bw
   4:     0x7f4027738893 - rt::unwind::begin_unwind::h4375279447423903650
   5:     0x7f4027738809 - diverges::h2266b4c4b850236beaa
   6:     0x7f40277389e5 - main::h19bb1149c2f00ecfBaa
   7:     0x7f402773f514 - rt::unwind::try::try_fn::h13186883479104382231
   8:     0x7f402773d1d8 - __rust_try
   9:     0x7f402773f201 - rt::lang_start::ha172a3ce74bb453aK5w
  10:     0x7f4027738a19 - main
  11:     0x7f402694ab44 - __libc_start_main
  12:     0x7f40277386c8 - <unknown>
  13:                0x0 - <unknown>
```

将`RUST_BACKTRACE`设置为0可关闭调用栈的输出：

```text
$ export RUST_BACKTRACE=1
...
$ RUST_BACKTRACE=0 ./diverges 
thread 'main' panicked at 'This function never returns!', hello.rs:2
note: Run with `RUST_BACKTRACE=1` for a backtrace.
```

`RUST_BACKTRACE`同样可配合Cargo的`run`命令：

```text
$ RUST_BACKTRACE=1 cargo run
     Running `target/debug/diverges`
thread 'main' panicked at 'This function never returns!', hello.rs:2
stack backtrace:
   1:     0x7f402773a829 - sys::backtrace::write::h0942de78b6c02817K8r
   2:     0x7f402773d7fc - panicking::on_panic::h3f23f9d0b5f4c91bu9w
   3:     0x7f402773960e - rt::unwind::begin_unwind_inner::h2844b8c5e81e79558Bw
   4:     0x7f4027738893 - rt::unwind::begin_unwind::h4375279447423903650
   5:     0x7f4027738809 - diverges::h2266b4c4b850236beaa
   6:     0x7f40277389e5 - main::h19bb1149c2f00ecfBaa
   7:     0x7f402773f514 - rt::unwind::try::try_fn::h13186883479104382231
   8:     0x7f402773d1d8 - __rust_try
   9:     0x7f402773f201 - rt::lang_start::ha172a3ce74bb453aK5w
  10:     0x7f4027738a19 - main
  11:     0x7f402694ab44 - __libc_start_main
  12:     0x7f40277386c8 - <unknown>
  13:                0x0 - <unknown>
```

偏函数可被当成任意类型使用：

```rust
# fn diverges() -> ! {
#    panic!("This function never returns!");
# }
let x: i32 = diverges();
let x: String = diverges();
```

## 函数指针

我们可以创建指向函数的变量绑定：

```rust
let f: fn(i32) -> i32;
```

上面的变量`f`指向一个函数，该函数接受且返回`i32`类型的参数。

```rust
fn plus_one(i: i32) -> i32 {
    i + 1
}

// without type inference
let f: fn(i32) -> i32 = plus_one;

// with type inference
let f = plus_one;
```

经过初始化后，我们就可以使用变量`f`调用函数了：

```rust
# fn plus_one(i: i32) -> i32 { i + 1 }
# let f = plus_one;
let six = f(5);
```
