% 模式

模式在Rust中经常被用到，我们一般在[变量绑定][bindings]和[match][match]中使用它。

[bindings]: 变量绑定.md
[match]: match.md

关于模式，你首先需要知道的是可以对任何字面量直接进行匹配，并且`_`表示任意匹配。

```rust
let x = 1;

match x {
    1 => println!("one"),
    2 => println!("two"),
    3 => println!("three"),
    _ => println!("anything"),
}
```

以上代码输出`one`。

模式匹配会引入新的变量绑定，它会使其它同名的变量绑定暂时不可用，例如：

```rust
let x = 1;
let c = 'c';

match c {
    x => println!("x: {} c: {}", x, c),
}

println!("x: {}", x)
```

上面的代码输出如下：

```text
x: c c: c
x: 1
```

上面的代码中，分支`x =>`创建了新的变量绑定`x`，该变量绑定在分支的表达式内有效。

# 多模式匹配

可使用`|`对多个模式同时进行匹配：

```rust
let x = 1;

match x {
    1 | 2 => println!("one or two"),
    3 => println!("three"),
    _ => println!("anything"),
}
```

以上代码输出`one or two`。

# 拆分

对于[`struct`][struct]这样的复合类型，你可以通过模式对其进行拆分：

```rust
struct Point {
    x: i32,
    y: i32,
}

let origin = Point { x: 0, y: 0 };

match origin {
    Point { x, y } => println!("({},{})", x, y),
}
```

[struct]: 结构体.md

可使用`:`为内部成员自定义变量绑定名称：

```rust
struct Point {
    x: i32,
    y: i32,
}

let origin = Point { x: 0, y: 0 };

match origin {
    Point { x: x1, y: y1 } => println!("({},{})", x1, y1),
}
```

如果我们只关心一部分数据，可以省略掉其它数据的匹配：

```rust
struct Point {
    x: i32,
    y: i32,
}

let point = Point { x: 2, y: 3 };

match point {
    Point { x, .. } => println!("x is {}", x),
}

```

以上代码的输出为`x is 2`。

你可以指定结构体的任意成员：

```rust
struct Point {
    x: i32,
    y: i32,
}

let point = Point { x: 2, y: 3 };

match point {
    Point { y, .. } => println!("y is {}", y),
}
```

以上代码输出`y is 3`。

模式不止可以拆分结构体，其它的复合类型也同样适用，如[元组][tuples]和[枚举][enums]。

[tuples]: 基本类型.md
[enums]: 枚举.md

# `_`模式

你可以在模式中使用`_`以表示忽略掉某部分类型和值，例如：

```rust
# let some_value: Result<i32, &'static str> = Err("There was an error");
match some_value {
    Ok(value) => println!("got a value: {}", value),
    Err(_) => println!("an error occurred"),
}
```

在上面的match语句中，我们在`Ok`分支将`value`绑定至其内部数据，在`Err`分支则忽略
了其内部数据。

`_`可出现在模式中任何创建单个变量绑定的地方，因此可用其很方便的忽略掉复合结构的
某些成员：

```rust
fn coordinate() -> (i32, i32, i32) {
    // generate and return some sort of triple tuple
# (1, 2, 3)
}

let (x, _, z) = coordinate();
```

在上面的`let`语句中，我们忽略了函数`coordinate()`返回的向量的第二个元素。

需要特别注意的是使用`_`会导致匹配到的值的所有权不发生变化：

```rust
let tuple: (u32, String) = (5, String::from("five"));

// Here, tuple is moved, because the String moved:
let (x, _s) = tuple;

// The next line would give "error: use of partially moved value: `tuple`"
// println!("Tuple is: {:?}", tuple);

// However,

let tuple = (5, String::from("five"));

// Here, tuple is _not_ moved, as the String was never moved, and u32 is Copy:
let (x, _) = tuple;

// That means this works:
println!("Tuple is: {:?}", tuple);
```

之前已经提过了，你还可以使用`..`忽略多个值：

```rust
enum OptionalTuple {
    Value(i32, i32, i32),
    Missing,
}

let x = OptionalTuple::Value(5, -2, 3);

match x {
    OptionalTuple::Value(..) => println!("Got a tuple!"),
    OptionalTuple::Missing => println!("No such luck."),
}
```

以上代码输出 `Got a tuple!`。

# ref and ref mut

如果你希望通过模式得到一个[引用][ref]，可以使用`ref`关键字：

```rust
let x = 5;

match x {
    ref r => println!("Got a reference to {}", r),
}
```

以上代码输出 `Got a reference to 5`.

[ref]: 引用和借用.md

以上代码的match表达式中的`r`是一个`&i32`类型的变量绑定。换句话说，`ref`关键字
_创建_了一个引用。如果你需要一个可变引用，可使用`ref mut`：

```rust
let mut x = 5;

match x {
    ref mut mr => println!("Got a mutable reference to {}", mr),
}
```

# 范围匹配

可通过操作符`...`匹配指定的数据范围：

```rust
let x = 1;

match x {
    1 ... 5 => println!("one through five"),
    _ => println!("anything"),
}
```

以上代码输出`one through five`。

范围操作符`...`一般用于整数和`char`：

```rust
let x = '💅';

match x {
    'a' ... 'j' => println!("early letter"),
    'k' ... 'z' => println!("late letter"),
    _ => println!("something else"),
}
```

以上代码输出`something else`。

# 绑定匹配值

你可使用`@`将匹配到的值绑定至指定变量名：

```rust
let x = 1;

match x {
    e @ 1 ... 5 => println!("got a range element {}", e),
    _ => println!("anything"),
}
```

以上代码输出`got a range element 1`。`@`通常用于进行较为复杂的拆分操作：

```rust
#[derive(Debug)]
struct Person {
    name: Option<String>,
}

let name = "Steve".to_string();
let x: Option<Person> = Some(Person { name: Some(name) });
match x {
    Some(Person { name: ref a @ Some(_), .. }) => println!("{:?}", a),
    _ => {}
}
```

以上代码输出`Some("Steve")`。`a`被绑定至了`Person`的`name`成员。

在`@`和`|`一起使用的情况下，你需要确保每个模式都被绑定至同一个名字：

```rust
let x = 5;

match x {
    e @ 1 ... 5 | e @ 8 ... 10 => println!("got a range element {}", e),
    _ => println!("anything"),
}
```

# 匹配条件

可通过`if`为`match`的分支添加匹配条件：

```rust
enum OptionalInt {
    Value(i32),
    Missing,
}

let x = OptionalInt::Value(5);

match x {
    OptionalInt::Value(i) if i > 5 => println!("Got an int bigger than five!"),
    OptionalInt::Value(..) => println!("Got an int!"),
    OptionalInt::Missing => println!("No such luck."),
}
```

以上代码输出`Got an int!`。

在使用多模式`|`的情况下，匹配条件被应用于所有模式：

```rust
let x = 4;
let y = false;

match x {
    4 | 5 if y => println!("yes"),
    _ => println!("no"),
}
```

以上代码输出`no`，因为`if`被应用至了整个模式`4 | 5`，其优先级如下：

```text
(4 | 5) if y => ...
```

而不是：

```text
4 | (5 if y) => ...
```

# 混合使用

以上介绍的各种模式匹配技巧可被结合起来使用，模式是非常强大的，要熟练使用它：

```rust
match x {
    Foo { x: Some(ref name), y: None } => ...
}
```
