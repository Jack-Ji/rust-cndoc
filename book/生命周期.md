% 声明周期

本章是专门介绍Rust的所有权概念的三章中的第一章。所有权是Rust的最为重要和吸引人的
特性，Rust开发者需要对其非常熟悉。借助所有权，Rust实现了其最大的目标：内存安全。
本文将分以下三章对所有权进行详细介绍：

* [所有权核心概念][ownership]
* [引用借用][borrowing]
* 生命周期，你正在阅读本章：）

这三章以循序渐进的方式对Rust的所有权的相关概念进行了介绍，你需要理解全部三章内容
才能准确无误的使用所有权系统。

[ownership]: 所有权.md
[borrowing]: 引用和借用.md

# 前言

在我们深入学习所有权的细节之前，首先要对以下两点有所了解：

Rust是一门强调安全和速度的编程语言，为了达成本目标Rust语言的抽象概念一般是通过
编译时的分析完成的，因此Rust语言的大部分特性不会增加运行时的开支。本文提到的所
有分析过程都是这样实现的。

然而这样一来，Rust语言的学习曲线相比其它语言会显得有些陡峭——很多Rust开发者新
写的代码都有可能会因为违反了所有权系统的判定而导致代码编译不通过，这是因为开发者
的脑中还未能建立起正确的所有权系统模型。你无需对此过于担心，根据我们的调查，很多
Rust开发者会随着开发经验的增长越来越习惯所有权系统，进而写出有效的代码。

# 生命周期

随着代码规模的提高，资源的借用也会复杂化，设想如下场景：

1. 我通过某种方式获取了某个资源；
2. 我将资源借给了你；
3. 我这里已经不需要再使用该资源了，因此我释放了它，尽管我之前将它借给了你。
4. 你仍然在继续使用该资源。

以上场景类似于我们在上一章中提到过的‘释放后使用’。

要避免这种错误，我们必须保证以上场景的第4步永远不会发生。Rust通过生命周期来分析
引用的有效范围，从而避免了上述错误的发生。生命周期即描述了一个引用的真正有效范围。

当函数通过引用方式接受一个参数时，我们即可以隐式也可以显式的指明引用的生命周期：

```rust
// 隐式
fn foo(x: &i32) {
}

// 显式
fn bar<'a>(x: &'a i32) {
}
```

上面代码中的`'a`可以理解为生命周期的名称。实际上，任何引用都有一个生命周期与其相
关联，只不过编译器允许你不显式指定而已（参看下面的生命周期默认规则）。`'a`这种写
法可能会略显怪异，我们可以这样思考：单引号意味着引用，a意味着引用有效范围的代号，
这样是不是就好理解些了？：）
下面让我们分析显式指定生命周期的代码：

```rust
fn bar<'a>(...)
```

我们在之前的[函数章节][functions]中介绍过了函数的语法，当时并没有提到函数名后面
的`<>`，实际上这是我们向函数传递泛型参数的方式，生命周期即为泛型参数之一。关于
泛型可以参看后面的[泛型章节][generics]。

[functions]: 函数.md
[generics]: 泛型.md

我们使用`<>`来声明生命周期，上面的代码可以理解为函数`bar`有一个生命周期`'a`。
生命周期可以有多个：

```rust
fn bar<'a, 'b>(...)
```

声明过后我们就可以在参数列表中使用生命周期了：

```rust
...(x: &'a i32)
```

如果函数接受的是一个`&mut`引用，可以写成这样：

```rust
...(x: &'a mut i32)
```

`&'a mut i32`可以理解为一个生命周期为`'a`的指向`i32`的可变引用。

# 结构体中的生命周期

在后面章节中会介绍[`结构体`][structs]，结构体在包含引用的情况下也需要显示指定其
生命周期：

```rust
struct Foo<'a> {
    x: &'a i32,
}

fn main() {
    let y = &5; // this is the same as `let _y = 5; let y = &_y;`
    let f = Foo { x: y };

    println!("{}", f.x);
}
```

[structs]: 结构体.md

如上所示，在struct中指定生命周期的方式与函数类似，同样通过泛型参数列表声明生命
周期，然后再在引用类型的声明中添加生命周期:

```rust
struct Foo<'a> {
# x: &'a i32,
# }
```

```rust
# struct Foo<'a> {
x: &'a i32,
# }
```

这里需要生命周期的原因是我们需要确保任何指向`Foo`的引用的有效范围不能超过其包含
的指向`i32`的引用的有效范围。

## `impl`语法

`impl`可用于为`Foo`添加方法：

```rust
struct Foo<'a> {
    x: &'a i32,
}

impl<'a> Foo<'a> {
    fn x(&self) -> &'a i32 { self.x }
}

fn main() {
    let y = &5; // this is the same as `let _y = 5; let y = &_y;`
    let f = Foo { x: y };

    println!("x is: {}", f.x());
}
```

就像函数声明一样，我们在`impl<'a>`中定义了生命周期`'a`，然后在`Foo<'a>`中使用了它。

## 多个生命周期

如果你有多个引用，你可以选择使用同一个生命周期多次：

```rust
fn x_or_y<'a>(x: &'a str, y: &'a str) -> &'a str {
#    x
# }
```

这意味着`x`和`y`两个引用的有效范围是相同的，并且返回的值也在同样的有效范围中。如
果你希望`x`和`y`的有效范围不相同，你可以使用多个生命周期参数：

```rust
fn x_or_y<'a, 'b>(x: &'a str, y: &'b str) -> &'a str {
#    x
# }
```

以上例子中，引用x和y有着不同的有效范围，而返回值的有效范围则与引用x相同。

## 理解生命周期的意义

理解生命周期的一个有效方式就是将其可视化：

```rust
fn main() {
    let y = &5;     // -+ y goes into scope
                    //  |
    // stuff        //  |
                    //  |
}                   // -+ y goes out of scope
```

我们的`Foo`结构体示例代码的生命周期则如下所示：

```rust
struct Foo<'a> {
    x: &'a i32,
}

fn main() {
    let y = &5;           // -+ y goes into scope
    let f = Foo { x: y }; // -+ f goes into scope
    // stuff              //  |
                          //  |
}                         // -+ f and y go out of scope
```

我们的Foo类型的变量`f`的有效范围被包含在`y`的有效范围中，因此一切ok。考虑下面的
反例情形：

```rust
struct Foo<'a> {
    x: &'a i32,
}

fn main() {
    let x;                    // -+ x goes into scope
                              //  |
    {                         //  |
        let y = &5;           // ---+ y goes into scope
        let f = Foo { x: y }; // ---+ f goes into scope
        x = &f.x;             //  | | error here
    }                         // ---+ f and y go out of scope
                              //  |
    println!("{}", x);        //  |
}                             // -+ x goes out of scope
```

如上所示，`f`和`y`的有效范围要小于`x`，我们使`x`错误的指向了即将失效的资源。

生命周期是对有效范围的正式命名，有了命名后我们才可能对有效范围进行进一步的讨论。

## 'static

`'static`生命周期意味着某个引用的有效范围是整个程序。

```rust
let x: &'static str = "Hello, world.";
```

字符串字面量的类型是`&'static str`，这是因为它可以在程序的任何位置被使用。另外
一个例子的全局变量：

```rust
static FOO: i32 = 5;
let x: &'static i32 = &FOO;
```

## 生命周期的默认规则

前面已经提到过了，生命周期在一些特定情况下是可以忽略不写的，Rust会按照默认规则
对生命周期进行处理。

下面我们将生命周期分为两类：*输入生命周期*和*输出生命周期*。输入生命周期指函数
参数的生命周期，输出生命周期指函数返回值的生命周期。下面的示例函数有一个输入生
命周期：

```rust
fn foo<'a>(bar: &'a str)
```

下面的示例函数有一个输出生命周期：

```rust
fn foo<'a>() -> &'a str
```

下面的示例函数则将同一个生命周期用于输入和输出：

```rust
fn foo<'a>(bar: &'a str) -> &'a str
```

以下是生命周期的三条准则：

* 函数参数列表中每个被忽略了生命周期的参数都有其单独的生命周期。

* 若函数仅有一个输入生命周期，无论忽略与否，该生命周期将被应用至函数输出中所有被
  忽略的生命周期。

* 如果函数有多个输入生命周期且其中一个参数的类型是`&self`或者`&mut self`，则`self`
  的生命周期将被应用至函数输出中所有被忽略的生命周期。

除以上情形外，生命周期不可被忽略。

### 示例

下面是一些忽略了生命周期的函数，我们在每个函数下方都提供了添加生命周期后的完整
函数原型：

```rust
fn print(s: &str); // elided
fn print<'a>(s: &'a str); // expanded

fn debug(lvl: u32, s: &str); // elided
fn debug<'a>(lvl: u32, s: &'a str); // expanded
```

在上面的例子中，参数`lvl`不需要生命周期，这是因为它不是一个引用类型。只有与引用
相关的代码才需要生命周期（如包含引用的`struct`）。

```rust
fn substr(s: &str, until: u32) -> &str; // elided
fn substr<'a>(s: &'a str, until: u32) -> &'a str; // expanded

fn get_str() -> &str; // ILLEGAL, no inputs

fn frob(s: &str, t: &str) -> &str; // ILLEGAL, two inputs
fn frob<'a, 'b>(s: &'a str, t: &'b str) -> &str; // Expanded: Output lifetime is ambiguous

fn get_mut(&mut self) -> &mut T; // elided
fn get_mut<'a>(&'a mut self) -> &'a mut T; // expanded

fn args<T: ToCStr>(&mut self, args: &[T]) -> &mut Command; // elided
fn args<'a, 'b, T: ToCStr>(&'a mut self, args: &'b [T]) -> &'a mut Command; // expanded

fn new(buf: &mut [u8]) -> BufWriter; // elided
fn new<'a>(buf: &'a mut [u8]) -> BufWriter<'a>; // expanded
```
