% 猜数字游戏

本章我们尝试用Rust实现经典的猜数字游戏。程序的基本流程是：
1）生成一个随机数；
2）提示玩家输入数字；
3）若玩家猜中数字则程序退出；
4）提示玩家数字猜的过大或过小，然后回到步骤2）；

在实现本游戏的过程中，我们会继续深入学习Rust。从下一章开始，我们会从基本语法和
语义开始较为系统的学习Rust语言。

# 创建工程

之前我们已经学习了如何创建新的工程，下面直接给出命令：

```bash
$ cd ~/projects
$ cargo new guessing_game --bin
$ cd guessing_game
```

检查生成的`Cargo.toml`文件：

```toml
[package]

name = "guessing_game"
version = "0.1.0"
authors = ["Your Name <you@example.com>"]
```

Cargo是根据开发环境自动生成的配置，开发者可以随时进行调整。

# 处理玩家输入的数字

下面我们需要在main函数中处理玩家输入的数字：

```rust
use std::io;

fn main() {
    println!("Guess the number!");

    println!("Please input your guess.");

    let mut guess = String::new();

    io::stdin().read_line(&mut guess)
        .expect("Failed to read line");

    println!("You guessed: {}", guess);
}
```

我们逐行分析上面的代码：

```rust
use std::io;
```

这一行代码的目的是加载标准库中的`io`子库，因为我们需要处理玩家的输入，并且将结果
作为输出。Rust默认会将标准库中属于[`prelude`][prelude]的部分加载到程序中。
`prelude`库的作用是将共享库中常用的组件封装到一起便于程序开发。`io`库里同样也有一
个[`prelude库`][ioprelude]，然而需要注意的是这个prelude库不会被自动加载至程序中，
需要玩家手动加载才能使用。

[prelude]: https://doc.rust-lang.org/std/prelude/index.html
[ioprelude]: https://doc.rust-lang.org/std/io/prelude/index.html

```rust
fn main() {
```

正如之前已经提到过的，`main()`函数是整个程序的入口。`fn`表示声明一个函数，`()`
表示函数不接受任何参数，`{`表示程序体的起始。因为我们未指定函数的返回类型，Rust
默认函数的返回为`()`，一个空的`元组`（[参看下一章][tuples]）。

[tuples]: 基本类型.md

```rust
    println!("Guess the number!");

    println!("Please input your guess.");
```

我们之前已经学习过了，`println!()`是对[宏][macros]的调用，其功能是向终端输出
[字符串][strings]。

[macros]: 宏.md
[strings]: 字符串.md

```rust
    let mut guess = String::new();
```

到这里事情就变得有趣些了，这行代码做了不少事情。首先，它使用了[let语句][let]，
其目的是创建变量绑定。变量绑定的基本形式如下：

```rust
let foo = bar;
```

[let]: 变量绑定.md

这条绑定语句创建了一个针对变量`bar`的绑定，命名为`foo`。在其它编程语言中，这一般
被称作为一个新的变量，而Rust之所以称其为变量绑定是因为其变量处理的特殊性。

举例来讲，变量绑定在Rust中默认是[不可变的][immutable]。这里我们在定义变量绑
定时使用了`mut`关键字：这样创建的变量绑定就是可变的了。`let`实际上将等号左边的
部分当成了[模式][patterns]来处理，而不是简单的变量名，这个我们后面再深究。现在
我们只需知道变量绑定被分为两类，可变和不可变：

```rust
let foo = 5; // 不可变
let mut bar = 5; // 可变
```

[immutable]: 变量可变性.md
[patterns]: 模式.md

和C/C++一样，`//`表示[注释][comments]的起始，一直到本行末尾。

[comments]: 注释.md

现在我们知道了`let mut guess`定义了一个命名为`guess`的可变的变量绑定，那么等号右
边的被绑定对象`String::new()`是什么呢？`String`是一个用于表示字符串的类型，是由
标准库提供的。一个[`String`][string]表示了一串可动态增长的、UTF-8编码的文本信息。

[string]: https://doc.rust-lang.org/std/string/struct.String.html

`::new()`语句使用了`::`符号，这是因为`new()`是与特定类型关联的函数，在本例即特指
`String`类型。注意是与类型而不是与类型实例相关联，在其它编程语言中这种函数一般被
称为静态方法。

这个函数的名称为`new()`，顾名思义，它创建了一个新的`String`实例。许多类型都以
`new()`作为创建实例的函数。

我们继续分析下面的代码：

```rust
    io::stdin().read_line(&mut guess)
        .expect("Failed to read line");
```

这行代码就更复杂了，我们一点一点来：

```rust
io::stdin()
```

这里我们调用了`io`库的`stdin()`函数，还记得我们在程序的开始加载了`std::io`库吗，
如果没有那么做，我们在这里就要写成`std::io::stdin()`。

这个函数向我们返回了当前终端的标准输入的句柄，
具体请参阅[std::io::Stdin][iostdin]。

[iostdin]: https://doc.rust-lang.org/std/io/struct.Stdin.html

下面的代码通过这个句柄从用户获取输入信息：

```rust
.read_line(&mut guess)
```

这里我们调用了句柄的[`read_line()`][read_line]方法。[方法][method]与上面的关联
函数类似，只不过它是被关联到特定类型的实例上的函数。

[read_line]: https://doc.rust-lang.org/std/io/struct.Stdin.html#method.read_line
[method]: 方法.md

还记得我们之前创建的guess绑定吗？我们已经提过了guess是个可变的变量绑定。这里需要
解释一下，为什么不能直接把guess传递给read_line函数。首先，`read_line`接受的参数
类型是`&mut String`，而不是`String`；Rust语言有个特性，我们称之为
[引用][references]，这个特性允许你通过多个引用访问同一块数据，从而降低了拷贝数据
的必要性。引用是个比较复杂的特性，Rust最大的卖点之一就是能够安全且较为简易的使用
引用。我们暂时不用深究其细节，这里我们只需知道和`let`绑定方式一样，引用也默认是
不可变的。因此，我们需要写成`&mut guess`，而不是`&guess`。

为什么`read_line()`需要一个可变的引用作为参数呢？很显然，这个函数的工作就是读取
用户的输入并将其放置到传入参数中，因此参数的类型必须为可变的。

[references]: 引用和借用.md

接下来的代码是：

```rust
        .expect("Failed to read line");
```

当你调用一个方法时，你可以添加换行符和空白符，这可以帮助你美化代码。虽然我们也
可以将代码写成：

```rust
    io::stdin().read_line(&mut guess).expect("failed to read line");
```

但是很显然这样的代码的可读性大大降低了。因此我们通常会将连续的方法调用分别写成
单独的行。那么这里的`expect()`方法是做什么用的呢？事实上，`read_line()`方法会
返回一个[`io::Result`][ioresult]类型的变量。Rust的标准库中有许多被命名为`Result`
的类型——它们其实都是基于同一个[`泛型Result`][result]，`io::Result`正是其中之一。

[ioresult]: https://doc.rust-lang.org/std/io/type.Result.html
[result]: https://doc.rust-lang.org/std/result/enum.Result.html

`Result`类型的目的是将错误信息封装起来，`Result`的实例同样也有关联的方法，这里
调用的[`expect()`方法][expect]正是其中之一。如果这里的`Result`实例代表了失败，
则[`panic!`][panic]会被调用，其入参正是你传给`expect`的参数。`panic!`的执行效果
是使程序崩溃，同时给出错误信息。

[expect]: https://doc.rust-lang.org/std/result/enum.Result.html#method.expect
[panic]: 错误处理.md

如果我们不调用`expect()`方法，程序在编译时会给出如下告警信息：

```bash
$ cargo build
   Compiling guessing_game v0.1.0 (file:///home/you/projects/guessing_game)
src/main.rs:10:5: 10:39 warning: unused result which must be used,
#[warn(unused_must_use)] on by default
src/main.rs:10     io::stdin().read_line(&mut guess);
                   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
```

可以看到，Rust编译器提醒了我们`Result`变量没有被使用，通过这种方式Rust告诉我们
程序中有错误可能未被处理。正确的方式是对函数返回加以处理，在这里我们希望程序
在遇到问题时奔溃即可，因此可以直接调用`expect()`方法。如果错误是能够通过某种方式
恢复的，我们就要采取其它的办法，这个我们留待后述。

现在就剩下最后一点代码了：

```rust
    println!("You guessed: {}", guess);
}
```

这里输出了我们保存的玩家输入的信息。`{}`是一个占位符，它会被我们实际传给
`println!`的guess参数所替代。如果我们有多个`{}`，我们就需要传入相应数量的参数：

```rust
let x = 5;
let y = 10;

println!("x and y: {} and {}", x, y);
```

很简单吧？

代码已经讲完了，现在我们可以运行程序了：

```bash
$ cargo run
   Compiling guessing_game v0.1.0 (file:///home/you/projects/guessing_game)
     Running `target/debug/guessing_game`
Guess the number!
Please input your guess.
6
You guessed: 6
```

好了！程序的第一阶段已经完成了，我们已经能够从键盘获取输入，并且将输入再输出到
屏幕上。

# 生成一个秘密数字

接下来，我们需要一个随机数生成器。Rust目前没有在标准库中提供随机数生成器，我们
需要使用一个[`rand` crate][randcrate]。'crate'表示一堆Rust编写的代码，可能是个
可运行的二进制程序，也可能是个共享库。这里所说的`rand`就是个共享库crate。

[randcrate]: https://crates.io/crates/rand

Cargo的优势在这个时候就体现出来了，我们在`Cargo.toml`配置中添加以下配置即可将依
赖的rand库加入工程：

```toml
[dependencies]

rand="0.3.0"
```

`[dependencies]`配置段和`[package]`一样，跟随在其后的所有配置都属于它，直到文件
结束或者另一个配置段开始。Cargo通过dependencies配置段获取项目所依赖的第三方库的
信息——名称、版本等。在本示例中，我们指定的版本号`0.3.0`是`^0.3.0`的简写方式，表
示所有与`0.3.0`相兼容的版本，具体参考[Semantic Versioning][semver]。
如果我们需要明确的指定使用`0.3.0`版本，配置应该写为`rand = "=0.3.0"`。
如果我们希望使用最新的版本，则配置应该写为`rand = "*"`。
[Cargo文档][cargodoc]中有更多的细节可参考。

[semver]: http://semver.org
[cargodoc]: http://doc.crates.io/specifying-dependencies.html

现在让我们再尝试编译代码：

```bash
$ cargo build
    Updating registry `https://github.com/rust-lang/crates.io-index`
 Downloading rand v0.3.8
 Downloading libc v0.1.6
   Compiling libc v0.1.6
   Compiling rand v0.3.8
   Compiling guessing_game v0.1.0 (file:///home/you/projects/guessing_game)
```

观察编译输出即可发现Cargo自动下载了依赖库的新版本，这是从[Crates.io][cratesio]
下载的。Crates.io是官方的Rust代码共享和发布中心。

[cratesio]: https://crates.io

在上面的输出中我们看Cargo还下载了libc库，这是因为rand库对libc库有依赖。

在上面我们提到了，我们所依赖的`rand`库的版本实际上是`0.3.x`。现在我们已经下载了
`0.3.8`版本，假如过一周后新的版本`0.3.9`发布了怎么办？`cargo build`命令是否会自
动更新版本呢？答案是否定的。这是因为新的版本在修复以前的bug的同时也可能会引入新
的bug，甚至接口的变化。`Cargo`的策略是记录上一次构建所用的版本，后续的构建会继续
使用上次构建所用的版本，除非开发者主动要求更新版本。那么`Cargo`是如何做到这一点
的呢？答案是通过`Cargo.lock`文件，`Cargo`在这个文件中记录上次构建中使用的版本，
之后`Cargo`每次运行时只要发现有`Cargo.lock`文件存在则直接使用该文件中记录的版本
信息。

那么如何告诉`Cargo`去更新版本呢？Cargo有个子命令专用于此：`update`。这个命令可以
使`Cargo`忽略当前的`Cargo.lock`文件，并重新尝试去确定依赖项的版本号，确定完成后
再将新的版本号写入`Cargo.lock`文件。之后当我们再次运行`cargo build`时，Cargo会
自动更新依赖库至新版本。

关于`Cargo`还有很多话题，感兴趣的读者可以去深入阅读[Cargo官方文档]【doccargo]，
并了解其[生态系统][doccratesio]。

[doccargo]: http://doc.crates.io
[doccratesio]: http://doc.crates.io/crates-io.html

下面让我们使用`rand`库来完善我们的程序：

```rust
extern crate rand;

use std::io;
use rand::Rng;

fn main() {
    println!("Guess the number!");

    let secret_number = rand::thread_rng().gen_range(1, 101);

    println!("The secret number is: {}", secret_number);

    println!("Please input your guess.");

    let mut guess = String::new();

    io::stdin().read_line(&mut guess)
        .expect("failed to read line");

    println!("You guessed: {}", guess);
}
```

我们在代码的第一行首先对引用的第三方库进行了声明：`extern crate rand;`。这行代码
的目的是告诉rust我们会在后面的代码中使用rand库，其作用和`use rand;`有些类似，后
续我们可以通过添加前缀`rand::`的方式来调用`rand`库中的接口。

接下来我们还添加了一行`use rand::Rng`，这行代码的目的是为了将`Rng`的定义告诉
rust。事实上，我们即将调用的`rand`模块的方法是被定义在名为`Rng`的traits中的，
为了能够使用该方法，`Rng`的定义必须被导入到当前编译单元中。
关于traits具体参见后续的[traits章节][traits]。

[traits]: traits.md

接下来是生成并打印随机数的代码：

```rust
    let secret_number = rand::thread_rng().gen_range(1, 101);

    println!("The secret number is: {}", secret_number);
```

我们使用`rand::thread_rng()`函数获取了一份随机数生成器的拷贝，该生成器属于当前
的执行上下文（[thread][concurrency])。由于我们在上面已经通过`use rand::Rng`导入
了相关traits的定义，这里我们可以调用`gen_range()`方法来获取随机数。这个方法接受
两个数值，返回结果是位于两个数之间的某个随机数（包含下限，不包含上限）。

[concurrency]: 并发.md

下面我们试着运行程序：

```bash
$ cargo run
   Compiling guessing_game v0.1.0 (file:///home/you/projects/guessing_game)
     Running `target/debug/guessing_game`
Guess the number!
The secret number is: 7
Please input your guess.
4
You guessed: 4
$ cargo run
     Running `target/debug/guessing_game`
Guess the number!
The secret number is: 83
Please input your guess.
5
You guessed: 5
```

看起来一切顺利，接下来我们需要比较随机数和玩家猜测的数字。

# 比较数字

下面我们添加比较数字的代码：

```rust
extern crate rand;

use std::io;
use std::cmp::Ordering;
use rand::Rng;

fn main() {
    println!("Guess the number!");

    let secret_number = rand::thread_rng().gen_range(1, 101);

    println!("The secret number is: {}", secret_number);

    println!("Please input your guess.");

    let mut guess = String::new();

    io::stdin().read_line(&mut guess)
        .expect("failed to read line");

    println!("You guessed: {}", guess);

    match guess.cmp(&secret_number) {
        Ordering::Less    => println!("Too small!"),
        Ordering::Greater => println!("Too big!"),
        Ordering::Equal   => println!("You win!"),
    }
}
```

首先，我们看到文件头部又添加了一行新的`use`语句，其目的是将`std::cmp::Ordering`
的定义加载进来。接下来是比较数字的语句：

```rust
match guess.cmp(&secret_number) {
    Ordering::Less    => println!("Too small!"),
    Ordering::Greater => println!("Too big!"),
    Ordering::Equal   => println!("You win!"),
}
```

`cmp()`方法可被任何能够作比较的类型调用，它接受的参数是比较的另一方的引用，比较
的返回结果是`Ordering`类型。我们使用[`match`][match]语句来判断返回的是`Ordering`
的哪个值。大家可能猜到了，`Ordering`实际上是个[枚举类型][enum]，其定义类似下方
代码：

```rust
enum Foo {
    Bar,
    Baz,
}
```

[match]: 模式匹配.md
[enum]: 枚举.md

从这个枚举定义我们可以得知，凡是`Foo`类型的变量要么是`Foo::Bar`，
要么是`Foo::Baz`。`::`符号被用来限定枚举定义的类型。

[`Ordering`][ordering]枚举类型有三种取值，`Less`，`Equal`和`Greater`。你可以根据
变量的取值在`match`语句中创建能够匹配的分支，这里我们可以创建三个分支：

```rust
match guess.cmp(&secret_number) {
    Ordering::Less    => println!("Too small!"),
    Ordering::Greater => println!("Too big!"),
    Ordering::Equal   => println!("You win!"),
}
```

[ordering]: https://doc.rust-lang.org/std/cmp/enum.Ordering.html

下面我们尝试编译程序：

```bash
$ cargo build
   Compiling guessing_game v0.1.0 (file:///home/you/projects/guessing_game)
src/main.rs:28:21: 28:35 error: mismatched types:
 expected `&collections::string::String`,
    found `&_`
(expected struct `collections::string::String`,
    found integral variable) [E0308]
src/main.rs:28     match guess.cmp(&secret_number) {
                                   ^~~~~~~~~~~~~~
error: aborting due to previous error
Could not compile `guessing_game`.
```

呃，程序编译出错了:(。观察错误信息可以知道主要原因是`mismatched types`。Rust语言
的类型系统是强静态的，这意味着类型的检查是在编译期进行的。通过guess的定义
`let guess = String::new()`，Rust可以推断出guess的类型是`String`。而`secret_number`
的类型则存在多种可能：32位有符号数`i32`、32位无符号数`u32`或者64位有符号数`i64`
等等。在本例中，Rust将guess的类型定为默认的`i32`。这样一来问题就产生了，Rust并
不知道如何比较字符串类型和整数类型，只有相同类型两个值才能用来比较。因此，我们
需要将`String`类型转换为整数类型才能进行比较。下面是修复bug后的代码：

```rust
extern crate rand;

use std::io;
use std::cmp::Ordering;
use rand::Rng;

fn main() {
    println!("Guess the number!");

    let secret_number = rand::thread_rng().gen_range(1, 101);

    println!("The secret number is: {}", secret_number);

    println!("Please input your guess.");

    let mut guess = String::new();

    io::stdin().read_line(&mut guess)
        .expect("failed to read line");

    let guess: u32 = guess.trim().parse()
        .expect("Please type a number!");

    println!("You guessed: {}", guess);

    match guess.cmp(&secret_number) {
        Ordering::Less    => println!("Too small!"),
        Ordering::Greater => println!("Too big!"),
        Ordering::Equal   => println!("You win!"),
    }
}
```

可以看到我们增加了两行代码：

```rust
    let guess: u32 = guess.trim().parse()
        .expect("Please type a number!");
```

等一等，我们不是已经定义过`guess`变量了吗？没错，但是Rust有个很方便的特性，它
允许我们用同样的变量名定义新的变量，老的变量会被自动屏蔽。利用这个特性，我们能够
很方便的重复利用一些常用的变量名，而不用搜肠刮肚的去想其它的奇葩名字（是程序员
都懂的吧）。这里我们重新将guess变量定义如下：

```rust
guess.trim().parse()
```

上面的`guess`代表了老的`guess`变量，表示玩家输入的字符串。`String`的`trim()`方法
可将字符串的开头和结尾的多余空白符给去掉，这非常关键，因为我们从`get_line()`得到
的输入并不是只有数字。举例来讲，玩家输入了`5`然后回车，那么`guess`的值实际上是
`5\n`，`\n`代表了换行符。`trim()`方法就可以将换行符给去掉，这样一来我们就能够通
过[`parse()`][parse]方法正确得出玩家输入的数字。由于`parse()`方法可以返回多种
数值类型，我们需要显式指定新变量`guess`的类型：`let guess: u32`，冒号`:`的作用
是告诉Rust我们期望的新变量的类型。Rust支持很多[数值类型][number]，这里我们选择了
`u32`，对于当前的例子来讲够用了。

[parse]: https://doc.rust-lang.org/std/primitive.str.html#method.parse
[number]: 基本类型.md

像之前使用的`read_line()`一样，`parse()`调用也可能会返回错误。举例来讲，如果一个
字符串包含了`A👍%`这样的字符，整个字符串就没有办法被合理的转换为数字。因此，我们
同样使用了`expect`方法让程序在字符串解析错误时直接崩溃。

下面试试我们的新程序：

```bash
$ cargo run
   Compiling guessing_game v0.1.0 (file:///home/you/projects/guessing_game)
     Running `target/guessing_game`
Guess the number!
The secret number is: 58
Please input your guess.
  76
You guessed: 76
Too big!
```

看起来不错，程序按照我们的意图执行的很好。我们几乎要完成程序的整个主体功能了，
现在我们只能猜一次数字就退出，下面需要添加一个循环，该循环在我们猜中数字之前
不会退出。

# 循环

`loop`关键字可以为我们创建一个循环体：

```rust
extern crate rand;

use std::io;
use std::cmp::Ordering;
use rand::Rng;

fn main() {
    println!("Guess the number!");

    let secret_number = rand::thread_rng().gen_range(1, 101);

    println!("The secret number is: {}", secret_number);

    loop {
        println!("Please input your guess.");

        let mut guess = String::new();

        io::stdin().read_line(&mut guess)
            .expect("failed to read line");

        let guess: u32 = guess.trim().parse()
            .expect("Please type a number!");

        println!("You guessed: {}", guess);

        match guess.cmp(&secret_number) {
            Ordering::Less    => println!("Too small!"),
            Ordering::Greater => println!("Too big!"),
            Ordering::Equal   => println!("You win!"),
        }
    }
}
```

编译运行程序，我们可以多次尝试猜测数字了！但是怎么退出游戏呢？还记得之前对
`parse()`的描述吗？如果我们给了一个非数字字符串，我们的程序就会崩溃退出：

```bash
$ cargo run
   Compiling guessing_game v0.1.0 (file:///home/you/projects/guessing_game)
     Running `target/guessing_game`
Guess the number!
The secret number is: 59
Please input your guess.
45
You guessed: 45
Too small!
Please input your guess.
60
You guessed: 60
Too big!
Please input your guess.
59
You guessed: 59
You win!
Please input your guess.
quit
thread 'main' panicked at 'Please type a number!'
```

成功了，`quit`管用了！很显然，我们输入其它的非数字字符串也能退出游戏，所以还需
要优化。首先，我们需要在猜中数字后退出游戏：

```rust
extern crate rand;

use std::io;
use std::cmp::Ordering;
use rand::Rng;

fn main() {
    println!("Guess the number!");

    let secret_number = rand::thread_rng().gen_range(1, 101);

    println!("The secret number is: {}", secret_number);

    loop {
        println!("Please input your guess.");

        let mut guess = String::new();

        io::stdin().read_line(&mut guess)
            .expect("failed to read line");

        let guess: u32 = guess.trim().parse()
            .expect("Please type a number!");

        println!("You guessed: {}", guess);

        match guess.cmp(&secret_number) {
            Ordering::Less    => println!("Too small!"),
            Ordering::Greater => println!("Too big!"),
            Ordering::Equal   => {
                println!("You win!");
                break;
            }
        }
    }
}
```

通过在match语句最后的分支上添加`break`语句，我们在猜中数字的同时就能够退出循环，
从而退出游戏了。下面我们需要调整对玩家输入错误的处理方式——如果玩家输入了非数字
字符串，程序应该将其忽略，而不是退出游戏：

```rust
extern crate rand;

use std::io;
use std::cmp::Ordering;
use rand::Rng;

fn main() {
    println!("Guess the number!");

    let secret_number = rand::thread_rng().gen_range(1, 101);

    println!("The secret number is: {}", secret_number);

    loop {
        println!("Please input your guess.");

        let mut guess = String::new();

        io::stdin().read_line(&mut guess)
            .expect("failed to read line");

        let guess: u32 = match guess.trim().parse() {
            Ok(num) => num,
            Err(_) => continue,
        };

        println!("You guessed: {}", guess);

        match guess.cmp(&secret_number) {
            Ordering::Less    => println!("Too small!"),
            Ordering::Greater => println!("Too big!"),
            Ordering::Equal   => {
                println!("You win!");
                break;
            }
        }
    }
}
```

主要的代码改动如下：

```rust
let guess: u32 = match guess.trim().parse() {
    Ok(num) => num,
    Err(_) => continue,
};
```
基本上这就是你如何显式处理函数返回错误的方式，使用match对返回值进行匹配判断，而
不是像之前使用`expect()`一样直接导致程序奔溃。
`Result`变量类型是个枚举，和`Ordering`比较类似，但是`Result`枚举变量可以与数据相
关联——`Ok`表示成功并且包含了成功解析后返回的数字，`Err`表示错误。
在这个例子中，我们我们使用`match`语句对`Ok(num)`进行模式匹配，从而将`parse()`正
确返回的数字作为变量`num`提取出来，并且将其作为整个match语句的返回值。当发生解析
错误时，即在`Err`分支中，我们并不关心错误的具体内容是什么，因此使用了`_`表示不对
枚举关联的变量进行捕获，我们只需使用continue让程序恢复执行即可。

基本ok了，让我们再运行一次程序：

```bash
$ cargo run
   Compiling guessing_game v0.1.0 (file:///home/you/projects/guessing_game)
     Running `target/guessing_game`
Guess the number!
The secret number is: 61
Please input your guess.
10
You guessed: 10
Too small!
Please input your guess.
99
You guessed: 99
Too big!
Please input your guess.
foo
Please input your guess.
61
You guessed: 61
You win!
```

一切都完美如期，太棒了！最后，我们需要将打印随机数的语句去掉，这样游戏才有乐趣，
不是吗？下面是最终的代码：

```rust
extern crate rand;

use std::io;
use std::cmp::Ordering;
use rand::Rng;

fn main() {
    println!("Guess the number!");

    let secret_number = rand::thread_rng().gen_range(1, 101);

    loop {
        println!("Please input your guess.");

        let mut guess = String::new();

        io::stdin().read_line(&mut guess)
            .expect("failed to read line");

        let guess: u32 = match guess.trim().parse() {
            Ok(num) => num,
            Err(_) => continue,
        };

        println!("You guessed: {}", guess);

        match guess.cmp(&secret_number) {
            Ordering::Less    => println!("Too small!"),
            Ordering::Greater => println!("Too big!"),
            Ordering::Equal   => {
                println!("You win!");
                break;
            }
        }
    }
}
```

# 完成！

这个工程向我们展示了rust的很多特性，包括：`let`、`match`、方法及如何使用第三方库
等等。

至此，你已经完成了猜数字游戏，恭喜你！
