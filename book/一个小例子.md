% 猜数字游戏

本章我们尝试用Rust实现经典的猜数字游戏。程序的基本流程是：
1）生成一个随机数；
2）提示玩家输入数字；
3）若玩家猜中数字则程序退出；
4）提示玩家数字猜的过大或过小，然后回到步骤2）；

在实现本游戏的过程中，我们会继续深入学习Rust。从下一章开始，我们会从基本语法和
语义开始较为系统的学习Rust语言。

# 创建工程

之前我们已经学习了如何创建新的工程，下面直接给出命令：

```bash
$ cd ~/projects
$ cargo new guessing_game --bin
$ cd guessing_game
```

检查生成的`Cargo.toml`文件：

```toml
[package]

name = "guessing_game"
version = "0.1.0"
authors = ["Your Name <you@example.com>"]
```

Cargo是根据开发环境自动生成的配置，开发者可以随时进行调整。

# 处理玩家输入的数字

下面我们需要在main函数中处理玩家输入的数字：

```rust
use std::io;

fn main() {
    println!("Guess the number!");

    println!("Please input your guess.");

    let mut guess = String::new();

    io::stdin().read_line(&mut guess)
        .expect("Failed to read line");

    println!("You guessed: {}", guess);
}
```

我们逐行分析上面的代码：

```rust
use std::io;
```

这一行代码的目的是加载标准库中的`io`子库，因为我们需要处理玩家的输入，并且将结果
作为输出。Rust默认会将标准库中属于[`prelude`][prelude]的部分加载到程序中。
`prelude`库的作用是将共享库中常用的组件封装到一起便于程序开发。`io`库里同样也有一
个[`prelude库`][ioprelude]，然而需要注意的是这个prelude库不会被自动加载至程序中，
需要玩家手动加载才能使用。

[prelude]: https://doc.rust-lang.org/std/prelude/index.html
[ioprelude]: https://doc.rust-lang.org/std/io/prelude/index.html

```rust
fn main() {
```

正如之前已经提到过的，`main()`函数是整个程序的入口。`fn`表示声明一个函数，`()`
表示函数不接受任何参数，`{`表示程序体的起始。因为我们未指定函数的返回类型，Rust
默认函数的返回为`()`，一个空的`元组`（[参看下一章][tuples]）。

[tuples]: 基本类型.md

```rust
    println!("Guess the number!");

    println!("Please input your guess.");
```

我们之前已经学习过了，`println!()`是对[宏][macros]的调用，其功能是向终端输出
[字符串][strings]。

[macros]: 宏.md
[strings]: 字符串.md

```rust
    let mut guess = String::new();
```

到这里事情就变得有趣些了，这行代码做了不少事情。首先，它使用了[let语句][let]，
其目的是创建变量绑定。变量绑定的基本形式如下：

```rust
let foo = bar;
```

[let]: 变量绑定.md

这条绑定语句创建了一个针对变量`bar`的绑定，命名为`foo`。在其它编程语言中，这一般
被称作为一个新的变量，而Rust之所以称其为变量绑定是因为其变量处理的特殊性。

举例来讲，变量绑定在Rust中默认是[不可变的][immutable]。这里我们在定义变量绑
定时使用了`mut`关键字：这样创建的变量绑定就是可变的了。`let`实际上将等号左边的
部分当成了[模式][patterns]来处理，而不是简单的变量名，这个我们后面再深究。现在
我们只需知道变量绑定被分为两类，可变和不可变：

```rust
let foo = 5; // 不可变
let mut bar = 5; // 可变
```

[immutable]: 变量可变性.md
[patterns]: 模式.md

和C/C++一样，`//`表示[注释][comments]的起始，一直到本行末尾。

[comments]: 注释.md

现在我们知道了`let mut guess`定义了一个命名为`guess`的可变的变量绑定，那么等号右
边的被绑定对象`String::new()`是什么呢？`String`是一个用于表示字符串的类型，是由
标准库提供的。一个[`String`][string]表示了一串可动态增长的、UTF-8编码的文本信息。

[string]: https://doc.rust-lang.org/std/string/struct.String.html

`::new()`语句使用了`::`符号，这是因为`new()`是与特定类型关联的函数，在本例即特指
`String`类型。注意是与类型而不是与类型实例相关联，在其它编程语言中这种函数一般被
称为静态方法。

这个函数的名称为`new()`，顾名思义，它创建了一个新的`String`实例。许多类型都以
`new()`作为创建实例的函数。

我们继续分析下面的代码：

```rust
    io::stdin().read_line(&mut guess)
        .expect("Failed to read line");
```

这行代码就更复杂了，我们一点一点来：

```rust
io::stdin()
```

这里我们调用了`io`库的`stdin()`函数，还记得我们在程序的开始加载了`std::io`库吗，
如果没有那么做，我们在这里就要写成`std::io::stdin()`。

这个函数向我们返回了当前终端的标准输入的句柄，
具体请参阅[std::io::Stdin][iostdin]。

[iostdin]: https://doc.rust-lang.org/std/io/struct.Stdin.html

下面的代码通过这个句柄从用户获取输入信息：

```rust
.read_line(&mut guess)
```

这里我们调用了句柄的[`read_line()`][read_line]方法。[方法][method]与上面的关联
函数类似，只不过它是被关联到特定类型的实例上的函数。

[read_line]: https://doc.rust-lang.org/std/io/struct.Stdin.html#method.read_line
[method]: 方法.md

还记得我们之前创建的guess绑定吗？我们已经提过了guess是个可变的变量绑定。这里需要
解释一下，为什么不能直接把guess传递给read_line函数。首先，`read_line`接受的参数
类型是`&mut String`，而不是`String`；Rust语言有个特性，我们称之为
[引用][references]，这个特性允许你通过多个引用访问同一块数据，从而降低了拷贝数据
的必要性。引用是个比较复杂的特性，Rust最大的卖点之一就是能够安全且较为简易的使用
引用。我们暂时不用深究其细节，这里我们只需知道和`let`绑定方式一样，引用也默认是
不可变的。因此，我们需要写成`&mut guess`，而不是`&guess`。

为什么`read_line()`需要一个可变的引用作为参数呢？很显然，这个函数的工作就是读取
用户的输入并将其放置到传入参数中，因此参数的类型必须为可变的。

[references]: 引用和借用.md

接下来的代码是：

```rust
        .expect("Failed to read line");
```

当你调用一个方法时，你可以添加换行符和空白符，这可以帮助你美化代码。虽然我们也
可以将代码写成：

```rust
    io::stdin().read_line(&mut guess).expect("failed to read line");
```

但是很显然这样的代码的可读性大大降低了。因此我们通常会将连续的方法调用分别写成
单独的行。那么这里的`expect()`方法是做什么用的呢？事实上，`read_line()`方法会
返回一个[`io::Result`][ioresult]类型的变量。Rust的标准库中有许多被命名为`Result`
的类型——它们其实都是基于同一个[`泛型Result`][result]，`io::Result`正是其中之一。

[ioresult]: https://doc.rust-lang.org/std/io/type.Result.html
[result]: https://doc.rust-lang.org/std/result/enum.Result.html

`Result`类型的目的是将错误信息封装起来，`Result`的实例同样也有关联的方法，这里
调用的[`expect()`方法][expect]正是其中之一。如果这里的`Result`实例代表了失败，
则[`panic!`][panic]会被调用，其入参正是你传给`expect`的参数。`panic!`的执行效果
是使程序崩溃，同时给出错误信息。

[expect]: https://doc.rust-lang.org/std/result/enum.Result.html#method.expect
[panic]: 错误处理.md

如果我们不调用`expect()`方法，程序在编译时会给出如下告警信息：

```bash
$ cargo build
   Compiling guessing_game v0.1.0 (file:///home/you/projects/guessing_game)
src/main.rs:10:5: 10:39 warning: unused result which must be used,
#[warn(unused_must_use)] on by default
src/main.rs:10     io::stdin().read_line(&mut guess);
                   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
```

可以看到，Rust编译器提醒了我们`Result`变量没有被使用，通过这种方式Rust告诉我们
程序中有错误可能未被处理。正确的方式是对函数返回加以处理，在这里我们希望程序
在遇到问题时奔溃即可，因此可以直接调用`expect()`方法。如果错误是能够通过某种方式
恢复的，我们就要采取其它的办法，这个我们留待后述。

现在就剩下最后一点代码了：

```rust
    println!("You guessed: {}", guess);
}
```

这里输出了我们保存的玩家输入的信息。`{}`是一个占位符，它会被我们实际传给
`println!`的guess参数所替代。如果我们有多个`{}`，我们就需要传入相应数量的参数：

```rust
let x = 5;
let y = 10;

println!("x and y: {} and {}", x, y);
```

很简单吧？

代码已经讲完了，现在我们可以运行程序了：

```bash
$ cargo run
   Compiling guessing_game v0.1.0 (file:///home/you/projects/guessing_game)
     Running `target/debug/guessing_game`
Guess the number!
Please input your guess.
6
You guessed: 6
```

好了！程序的第一阶段已经完成了，我们已经能够从键盘获取输入，并且将输入再输出到
屏幕上。

# 生成一个秘密数字

接下来，我们需要一个随机数生成器。Rust目前没有在标准库中提供随机数生成器，我们
需要使用一个[`rand` crate][randcrate]。'crate'表示一堆Rust编写的代码，可能是个
可运行的二进制程序，也可能是个共享库。这里所说的`rand`就是个共享库crate。

[randcrate]: https://crates.io/crates/rand

Cargo的优势在这个时候就体现出来了，我们在`Cargo.toml`配置中添加以下配置即可将依
赖的rand库加入工程：

```toml
[dependencies]

rand="0.3.0"
```

`[dependencies]`配置段和`[package]`一样，跟随在其后的所有配置都属于它，直到文件
结束或者另一个配置段开始。Cargo通过dependencies配置段获取项目所依赖的第三方库的
信息——名称、版本等。在本示例中，我们指定的版本号`0.3.0`是`^0.3.0`的简写方式，表
示所有与`0.3.0`相兼容的版本，具体参考[Semantic Versioning][semver]。
如果我们需要明确的指定使用`0.3.0`版本，配置应该写为`rand = "=0.3.0"`。
如果我们希望使用最新的版本，则配置应该写为`rand = "*"`。
[Cargo文档][cargodoc]中有更多的细节可参考。

[semver]: http://semver.org
[cargodoc]: http://doc.crates.io/specifying-dependencies.html

现在让我们再尝试编译代码：

```bash
$ cargo build
    Updating registry `https://github.com/rust-lang/crates.io-index`
 Downloading rand v0.3.8
 Downloading libc v0.1.6
   Compiling libc v0.1.6
   Compiling rand v0.3.8
   Compiling guessing_game v0.1.0 (file:///home/you/projects/guessing_game)
```

观察编译输出即可发现Cargo自动下载了依赖库的新版本，这是从[Crates.io][cratesio]
下载的。Crates.io是官方的Rust代码共享和发布中心。

[cratesio]: https://crates.io

在上面的输出中我们看Cargo还下载了libc库，这是因为rand库对libc库有依赖。

在上面我们提到了，我们所依赖的`rand`库的版本实际上是`0.3.x`。现在我们已经下载了
`0.3.8`版本，假如过一周后新的版本`0.3.9`发布了怎么办？`cargo build`命令是否会自
动更新版本呢？答案是否定的。这是因为新的版本在修复以前的bug的同时也可能会引入新
的bug，甚至接口的变化。`Cargo`的策略是记录上一次构建所用的版本，后续的构建会继续
使用上次构建所用的版本，除非开发者主动要求更新版本。那么`Cargo`是如何做到这一点
的呢？答案是通过`Cargo.lock`文件，`Cargo`在这个文件中记录上次构建中使用的版本，
之后`Cargo`每次运行时只要发现有`Cargo.lock`文件存在则直接使用该文件中记录的版本
信息。

那么如何告诉`Cargo`去更新版本呢？Cargo有个子命令专用于此：`update`。这个命令可以
使`Cargo`忽略当前的`Cargo.lock`文件，并重新尝试去确定依赖项的版本号，确定完成后
再将新的版本号写入`Cargo.lock`文件。之后当我们再次运行`cargo build`时，Cargo会
自动更新依赖库至新版本。

关于`Cargo`还有很多话题，感兴趣的读者可以去深入阅读[Cargo官方文档]【doccargo]，
并了解其[生态系统][doccratesio]。

[doccargo]: http://doc.crates.io
[doccratesio]: http://doc.crates.io/crates-io.html

下面让我们使用`rand`库来完善我们的程序：

```rust
extern crate rand;

use std::io;
use rand::Rng;

fn main() {
    println!("Guess the number!");

    let secret_number = rand::thread_rng().gen_range(1, 101);

    println!("The secret number is: {}", secret_number);

    println!("Please input your guess.");

    let mut guess = String::new();

    io::stdin().read_line(&mut guess)
        .expect("failed to read line");

    println!("You guessed: {}", guess);
}
```

我们在代码的第一行首先对引用的第三方库进行了声明：`extern crate rand;`。这行代码
的目的是告诉rust我们会在后面的代码中使用rand库，其作用和`use rand;`有些类似，后
续我们可以通过添加前缀`rand::`的方式来调用`rand`库中的接口。

接下来我们还添加了一行`use rand::Rng`，这行代码的目的是为了将`Rng`的定义告诉
rust。事实上，我们即将调用的`rand`模块的方法是被定义在traits中的，为了能够使用
该方法，traits的定义必须被导入到当前编译单元中。具体参见后续的[traits][traits]。

[traits]: traits.md

接下来是生成并打印随机数的代码：

```rust
    let secret_number = rand::thread_rng().gen_range(1, 101);

    println!("The secret number is: {}", secret_number);
```

我们使用`rand::thread_rng()`函数获取了一份随机数生成器的拷贝，该生成器属于当前
的执行上下文（[thread][concurrency])。由于我们在上面已经通过`use rand::Rng`导入
了相关traits的定义，这里我们可以调用`gen_range()`方法来获取随机数。这个方法接受
两个数值，返回结果是位于两个数之间的某个随机数（包含下限，不包含上限）。

[concurrency]: 并发.md

下面我们试着运行程序：

```bash
$ cargo run
   Compiling guessing_game v0.1.0 (file:///home/you/projects/guessing_game)
     Running `target/debug/guessing_game`
Guess the number!
The secret number is: 7
Please input your guess.
4
You guessed: 4
$ cargo run
     Running `target/debug/guessing_game`
Guess the number!
The secret number is: 83
Please input your guess.
5
You guessed: 5
```

看起来一切顺利，接下来我们需要比较随机数和玩家猜测的数字。

# Comparing guesses

Now that we’ve got user input, let’s compare our guess to the secret number.
Here’s our next step, though it doesn’t quite compile yet:

```rust
extern crate rand;

use std::io;
use std::cmp::Ordering;
use rand::Rng;

fn main() {
    println!("Guess the number!");

    let secret_number = rand::thread_rng().gen_range(1, 101);

    println!("The secret number is: {}", secret_number);

    println!("Please input your guess.");

    let mut guess = String::new();

    io::stdin().read_line(&mut guess)
        .expect("failed to read line");

    println!("You guessed: {}", guess);

    match guess.cmp(&secret_number) {
        Ordering::Less    => println!("Too small!"),
        Ordering::Greater => println!("Too big!"),
        Ordering::Equal   => println!("You win!"),
    }
}
```

A few new bits here. The first is another `use`. We bring a type called
`std::cmp::Ordering` into scope. Then, five new lines at the bottom that use
it:

```rust
match guess.cmp(&secret_number) {
    Ordering::Less    => println!("Too small!"),
    Ordering::Greater => println!("Too big!"),
    Ordering::Equal   => println!("You win!"),
}
```

The `cmp()` method can be called on anything that can be compared, and it
takes a reference to the thing you want to compare it to. It returns the
`Ordering` type we `use`d earlier. We use a [`match`][match] statement to
determine exactly what kind of `Ordering` it is. `Ordering` is an
[`enum`][enum], short for ‘enumeration’, which looks like this:

```rust
enum Foo {
    Bar,
    Baz,
}
```

[match]: 模式匹配.md
[enum]: 枚举.md

With this definition, anything of type `Foo` can be either a
`Foo::Bar` or a `Foo::Baz`. We use the `::` to indicate the
namespace for a particular `enum` variant.

The [`Ordering`][ordering] `enum` has three possible variants: `Less`, `Equal`,
and `Greater`. The `match` statement takes a value of a type, and lets you
create an ‘arm’ for each possible value. Since we have three types of
`Ordering`, we have three arms:

```rust
match guess.cmp(&secret_number) {
    Ordering::Less    => println!("Too small!"),
    Ordering::Greater => println!("Too big!"),
    Ordering::Equal   => println!("You win!"),
}
```

[ordering]: https://doc.rust-lang.org/std/cmp/enum.Ordering.html

If it’s `Less`, we print `Too small!`, if it’s `Greater`, `Too big!`, and if
`Equal`, `You win!`. `match` is really useful, and is used often in Rust.

I did mention that this won’t quite compile yet, though. Let’s try it:

```bash
$ cargo build
   Compiling guessing_game v0.1.0 (file:///home/you/projects/guessing_game)
src/main.rs:28:21: 28:35 error: mismatched types:
 expected `&collections::string::String`,
    found `&_`
(expected struct `collections::string::String`,
    found integral variable) [E0308]
src/main.rs:28     match guess.cmp(&secret_number) {
                                   ^~~~~~~~~~~~~~
error: aborting due to previous error
Could not compile `guessing_game`.
```

Whew! This is a big error. The core of it is that we have ‘mismatched types’.
Rust has a strong, static type system. However, it also has type inference.
When we wrote `let guess = String::new()`, Rust was able to infer that `guess`
should be a `String`, and so it doesn’t make us write out the type. And with
our `secret_number`, there are a number of types which can have a value
between one and a hundred: `i32`, a thirty-two-bit number, or `u32`, an
unsigned thirty-two-bit number, or `i64`, a sixty-four-bit number or others.
So far, that hasn’t mattered, and so Rust defaults to an `i32`. However, here,
Rust doesn’t know how to compare the `guess` and the `secret_number`. They
need to be the same type. Ultimately, we want to convert the `String` we
read as input into a real number type, for comparison. We can do that
with two more lines. Here’s our new program:

```rust
extern crate rand;

use std::io;
use std::cmp::Ordering;
use rand::Rng;

fn main() {
    println!("Guess the number!");

    let secret_number = rand::thread_rng().gen_range(1, 101);

    println!("The secret number is: {}", secret_number);

    println!("Please input your guess.");

    let mut guess = String::new();

    io::stdin().read_line(&mut guess)
        .expect("failed to read line");

    let guess: u32 = guess.trim().parse()
        .expect("Please type a number!");

    println!("You guessed: {}", guess);

    match guess.cmp(&secret_number) {
        Ordering::Less    => println!("Too small!"),
        Ordering::Greater => println!("Too big!"),
        Ordering::Equal   => println!("You win!"),
    }
}
```

The new two lines:

```rust
    let guess: u32 = guess.trim().parse()
        .expect("Please type a number!");
```

Wait a minute, I thought we already had a `guess`? We do, but Rust allows us
to ‘shadow’ the previous `guess` with a new one. This is often used in this
exact situation, where `guess` starts as a `String`, but we want to convert it
to an `u32`. Shadowing lets us re-use the `guess` name, rather than forcing us
to come up with two unique names like `guess_str` and `guess`, or something
else.

We bind `guess` to an expression that looks like something we wrote earlier:

```rust
guess.trim().parse()
```

Here, `guess` refers to the old `guess`, the one that was a `String` with our
input in it. The `trim()` method on `String`s will eliminate any white space at
the beginning and end of our string. This is important, as we had to press the
‘return’ key to satisfy `read_line()`. This means that if we type `5` and hit
return, `guess` looks like this: `5\n`. The `\n` represents ‘newline’, the
enter key. `trim()` gets rid of this, leaving our string with only the `5`. The
[`parse()` method on strings][parse] parses a string into some kind of number.
Since it can parse a variety of numbers, we need to give Rust a hint as to the
exact type of number we want. Hence, `let guess: u32`. The colon (`:`) after
`guess` tells Rust we’re going to annotate its type. `u32` is an unsigned,
thirty-two bit integer. Rust has [a number of built-in number types][number],
but we’ve chosen `u32`. It’s a good default choice for a small positive number.

[parse]: https://doc.rust-lang.org/std/primitive.str.html#method.parse
[number]: 基本类型.md

Just like `read_line()`, our call to `parse()` could cause an error. What if
our string contained `A👍%`? There’d be no way to convert that to a number. As
such, we’ll do the same thing we did with `read_line()`: use the `expect()`
method to crash if there’s an error.

Let’s try our program out!

```bash
$ cargo run
   Compiling guessing_game v0.1.0 (file:///home/you/projects/guessing_game)
     Running `target/guessing_game`
Guess the number!
The secret number is: 58
Please input your guess.
  76
You guessed: 76
Too big!
```

Nice! You can see I even added spaces before my guess, and it still figured
out that I guessed 76. Run the program a few times, and verify that guessing
the number works, as well as guessing a number too small.

Now we’ve got most of the game working, but we can only make one guess. Let’s
change that by adding loops!

# Looping

The `loop` keyword gives us an infinite loop. Let’s add that in:

```rust
extern crate rand;

use std::io;
use std::cmp::Ordering;
use rand::Rng;

fn main() {
    println!("Guess the number!");

    let secret_number = rand::thread_rng().gen_range(1, 101);

    println!("The secret number is: {}", secret_number);

    loop {
        println!("Please input your guess.");

        let mut guess = String::new();

        io::stdin().read_line(&mut guess)
            .expect("failed to read line");

        let guess: u32 = guess.trim().parse()
            .expect("Please type a number!");

        println!("You guessed: {}", guess);

        match guess.cmp(&secret_number) {
            Ordering::Less    => println!("Too small!"),
            Ordering::Greater => println!("Too big!"),
            Ordering::Equal   => println!("You win!"),
        }
    }
}
```

And try it out. But wait, didn’t we just add an infinite loop? Yup. Remember
our discussion about `parse()`? If we give a non-number answer, we’ll `panic!`
and quit. Observe:

```bash
$ cargo run
   Compiling guessing_game v0.1.0 (file:///home/you/projects/guessing_game)
     Running `target/guessing_game`
Guess the number!
The secret number is: 59
Please input your guess.
45
You guessed: 45
Too small!
Please input your guess.
60
You guessed: 60
Too big!
Please input your guess.
59
You guessed: 59
You win!
Please input your guess.
quit
thread 'main' panicked at 'Please type a number!'
```

Ha! `quit` actually quits. As does any other non-number input. Well, this is
suboptimal to say the least. First, let’s actually quit when you win the game:

```rust
extern crate rand;

use std::io;
use std::cmp::Ordering;
use rand::Rng;

fn main() {
    println!("Guess the number!");

    let secret_number = rand::thread_rng().gen_range(1, 101);

    println!("The secret number is: {}", secret_number);

    loop {
        println!("Please input your guess.");

        let mut guess = String::new();

        io::stdin().read_line(&mut guess)
            .expect("failed to read line");

        let guess: u32 = guess.trim().parse()
            .expect("Please type a number!");

        println!("You guessed: {}", guess);

        match guess.cmp(&secret_number) {
            Ordering::Less    => println!("Too small!"),
            Ordering::Greater => println!("Too big!"),
            Ordering::Equal   => {
                println!("You win!");
                break;
            }
        }
    }
}
```

By adding the `break` line after the `You win!`, we’ll exit the loop when we
win. Exiting the loop also means exiting the program, since it’s the last
thing in `main()`. We have only one more tweak to make: when someone inputs a
non-number, we don’t want to quit, we want to ignore it. We can do that
like this:

```rust
extern crate rand;

use std::io;
use std::cmp::Ordering;
use rand::Rng;

fn main() {
    println!("Guess the number!");

    let secret_number = rand::thread_rng().gen_range(1, 101);

    println!("The secret number is: {}", secret_number);

    loop {
        println!("Please input your guess.");

        let mut guess = String::new();

        io::stdin().read_line(&mut guess)
            .expect("failed to read line");

        let guess: u32 = match guess.trim().parse() {
            Ok(num) => num,
            Err(_) => continue,
        };

        println!("You guessed: {}", guess);

        match guess.cmp(&secret_number) {
            Ordering::Less    => println!("Too small!"),
            Ordering::Greater => println!("Too big!"),
            Ordering::Equal   => {
                println!("You win!");
                break;
            }
        }
    }
}
```

These are the lines that changed:

```rust
let guess: u32 = match guess.trim().parse() {
    Ok(num) => num,
    Err(_) => continue,
};
```
This is how you generally move from ‘crash on error’ to ‘actually handle the
error’, by switching from `expect()` to a `match` statement. A `Result` is
returned by `parse()`, this is an `enum`  like `Ordering`, but in this case,
each variant has some data associated with it: `Ok` is a success, and `Err` is a
failure. Each contains more information: the successfully parsed integer, or an
error type. In this case, we `match` on `Ok(num)`, which sets the name `num` to
the unwrapped `Ok` value (the integer), and then we  return it on the
right-hand side. In the `Err` case, we don’t care what kind of error it is, so
we just use the catch all `_` instead of a name. This catches everything that
isn't `Ok`, and `continue` lets us move to the next iteration of the loop; in
effect, this enables us to ignore all errors and continue with our program.

Now we should be good! Let’s try:

```bash
$ cargo run
   Compiling guessing_game v0.1.0 (file:///home/you/projects/guessing_game)
     Running `target/guessing_game`
Guess the number!
The secret number is: 61
Please input your guess.
10
You guessed: 10
Too small!
Please input your guess.
99
You guessed: 99
Too big!
Please input your guess.
foo
Please input your guess.
61
You guessed: 61
You win!
```

Awesome! With one tiny last tweak, we have finished the guessing game. Can you
think of what it is? That’s right, we don’t want to print out the secret
number. It was good for testing, but it kind of ruins the game. Here’s our
final source:

```rust
extern crate rand;

use std::io;
use std::cmp::Ordering;
use rand::Rng;

fn main() {
    println!("Guess the number!");

    let secret_number = rand::thread_rng().gen_range(1, 101);

    loop {
        println!("Please input your guess.");

        let mut guess = String::new();

        io::stdin().read_line(&mut guess)
            .expect("failed to read line");

        let guess: u32 = match guess.trim().parse() {
            Ok(num) => num,
            Err(_) => continue,
        };

        println!("You guessed: {}", guess);

        match guess.cmp(&secret_number) {
            Ordering::Less    => println!("Too small!"),
            Ordering::Greater => println!("Too big!"),
            Ordering::Equal   => {
                println!("You win!");
                break;
            }
        }
    }
}
```

# Complete!

This project showed you a lot: `let`, `match`, methods, associated
functions, using external crates, and more.

At this point, you have successfully built the Guessing Game! Congratulations!
