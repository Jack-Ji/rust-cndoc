% 字符串

字符串是任何编程人员都要经常用的数据类型。Rust中的字符串是一种变长数据结构，
与C语言的字符串完全不同。Rust的一个字符串代表一个utf-8编码的unicode序列，而不像
C/C++中是以空值结尾的ASCII码序列。

Rust有两种字符串类型：`&str`和`String`。`&str`是字符串切片，字符串切片有固定的
长度，且不可被修改，它表示对utf-8序列的引用：

```rust
let greeting = "Hello there."; // greeting: &'static str
```

`"Hello there."`是一个字符串字面量，它的类型是`&'static str`。字符串字面量是静态
分配的，这意味着它会被编译到我们的程序中，并且在整个程序运行期间一直存在。接受字
符串切片为参数的函数同样可接受字符串字面量。

字符串字面量可以跨越多行，有两种写法，首先是包含了换行符的字符串：

```rust
let s = "foo
    bar";

assert_eq!("foo\n    bar", s);
```

还可以使用`\`将字符串字面量分成多行，末尾的`\`及后面的空白符会被忽略：

```rust
let s = "foo\
    bar";

assert_eq!("foobar", s);
```

大多数情况下你不会直接使用`str`类型，总是使用`&str`类型。这是因为`str`类型占用的
空间是不确定的，Rust需要一些运行时信息才能使用它。
更多相关内容可以参考[unsized types][ut]。

下面我们该讨论`String`类型了，`String`是基于堆内存的字符串类型，该类型的字符串可
动态增长的，且同样是utf-8编码的字符序列。`String`通常通过调用字符串切片的`to_string`
方法得到。

```rust
let mut s = "Hello".to_string(); // mut s: String
println!("{}", s);

s.push_str(", world.");
println!("{}", s);
```

可通过`&`将`String`类型转换为`&str`类型：

```rust
fn takes_slice(slice: &str) {
    println!("Got: {}", slice);
}

fn main() {
    let s = "Hello".to_string();
    takes_slice(&s);
}
```

在函数或方法接受的参数不是`&str`而是`&str`的某个traits时，以上强制转换不再生效。
以[`TcpStream::connect`][connect]为例，该函数接受的参数是`ToSocketAddrs` trait，
`&str`可直接做为参数进行传递，而`String`需要通过`&*`强制转换才行。

```rust
use std::net::TcpStream;

TcpStream::connect("192.168.0.1:3000"); // &str parameter

let addr_string = "192.168.0.1:3000".to_string();
TcpStream::connect(&*addr_string); // convert addr_string to &str
```

将`String`转换为`&str`基本不存在cpu和内存消耗，而将`&str`转换为`String`则需要分
配内存，因此没有特别需要尽量不要做`&str`至`String`的转换。

## 字符串索引

由于字符串的编码是utf-8（单个字符占用空间是不定长的），通过数组下标方式访问
单个字符是不允许的：

```rust
let s = "hello";

println!("The first letter of s is {}", s[0]); // ERROR!!!
```

字符串可被转换为字节或者`codepoint`序列再访问：

```rust
let hachiko = "忠犬ハチ公";

for b in hachiko.as_bytes() {
    print!("{}, ", b);
}

println!("");

for c in hachiko.chars() {
    print!("{}, ", c);
}

println!("");
```

以上代码输出：

```text
229, 191, 160, 231, 138, 172, 227, 131, 143, 227, 131, 129, 229, 133, 172,
忠, 犬, ハ, チ, 公,
```

正如你所看到的，一个字符可能对应多个字节。

可通过如下方式实现对字符串单个字符的访问：

```rust
# let hachiko = "忠犬ハチ公";
let dog = hachiko.chars().nth(1); // kinda like hachiko[1]
```

需要强调的是我们需要从字符串的起始遍历才能得到下标指定的第n个字符。

## 字符串切片

和数组一样，我们同样可创建字符串的切片：

```rust
let dog = "hachiko";
let hachi = &dog[0..5];
```

需要注意的是，切片下标范围是以字节为单位的，因此以下代码会报错：

```rust
let dog = "忠犬ハチ公";
let hachi = &dog[0..2];
```

```text
thread 'main' panicked at 'index 0 and/or 2 in `忠犬ハチ公` do not lie on
character boundary'
```

## 拼接字符串

你可以将一个`&str`变量拼接到一个`String`变量后面：

```rust
let hello = "Hello ".to_string();
let world = "world!";

let hello_world = hello + world;
```

如果你有两个`String`变量，你需要将`+`右边的变量做转换（使用&）：

```rust
let hello = "Hello ".to_string();
let world = "world!".to_string();

let hello_world = hello + &world;
```

[ut]: unsized-types.md
[dc]: deref-coercions.md
[connect]: https://doc.rust-lang.org/std/net/struct.TcpStream.html#method.connect
