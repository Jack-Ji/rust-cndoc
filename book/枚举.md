% 枚举

在Rust中，枚举（`enum`）是将多种数据合而为一的手段，枚举的实例只能是其支持的数据
种类之一：

```rust
enum Message {
    Quit,
    ChangeColor(i32, i32, i32),
    Move { x: i32, y: i32 },
    Write(String),
}
```

定义枚举的数据种类的方式与结构体的定义比较类似，区别是没有`struct`关键字而已，除
此以外其定义方式和单元结构体、元结构体、正常结构体的定义方式一模一样。

我们使用`::`操作符选取枚举支持的某种数据，实际上枚举定义类似于一个命名空间，因为
我们在不同枚举中可以定义相同名称的数据种类：

```rust
# enum Message {
#     Move { x: i32, y: i32 },
# }
let x: Message = Message::Move { x: 3, y: 4 };

enum BoardGameTurn {
    Move { squares: i32 },
    Pass,
}

let y: BoardGameTurn = BoardGameTurn::Move { squares: 1 };
```

枚举的实例只能和其支持的一种数据相匹配，不能随意选择：

```rust
fn process_color_change(msg: Message) {
    let Message::ChangeColor(r, g, b) = msg; // compile-time error
}
```

判断一个枚举实例是否是枚举的某种数据有两种方式：1）为该枚举类型实现比较操作；
2）使用[match][match]操作符。我们将在[`traits`][traits]章节中学会如何为某个类型
实现比较操作。

[match]: match.md
[traits]: traits.md

# "枚举构造函数"

枚举实例的创建可以使用类似构造函数调用的方式，例如：

```rust
# enum Message {
# Write(String),
# }
let m = Message::Write("Hello, world".to_string());
```

上面的代码和下面是等同的：

```rust
# enum Message {
# Write(String),
# }
fn foo(x: String) -> Message {
    Message::Write(x)
}

let x = foo("Hello, world".to_string());
```

枚举构造函数暂时看起来可能用处不大，在后面的[`闭包章节`][closures]和
[`迭代器章节`][iterators]中，我们会讨论将函数作为参数传递给函数，下面给出的
示例代码将一个字符串向量转换成为了一个`Message:Write`向量，其中就应用到了枚举
构造函数：

```rust
# enum Message {
# Write(String),
# }

let v = vec!["Hello".to_string(), "World".to_string()];

let v1: Vec<Message> = v.into_iter().map(Message::Write).collect();
```

[closures]: 闭包.md
[iterators]: 迭代器.md
