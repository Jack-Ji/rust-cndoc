% 方法

函数很好用，然而如果你有很多函数都对同一个数据结构进行操作，函数就有些麻烦了：

```rust
baz(bar(foo));
```

上面代码中的数据实例foo首先被函数bar处理，然后再被函数baz处理，显然代码中函数的
顺序与实际调用顺序是相反的，很奇怪不是吗？我们希望能够以一致的方式写出函数的调用，
就像下面的代码一样：

```rust
foo.bar().baz();
```

很显然，这类似于C++和Java中面向对象的方法调用。在Rust中，我们同样可以为符合类型
定义方法。

# 方法定义和调用

下面的示例代码为数据结构`Circle`定义了`area`方法：

```rust
struct Circle {
    x: f64,
    y: f64,
    radius: f64,
}

impl Circle {
    fn area(&self) -> f64 {
        std::f64::consts::PI * (self.radius * self.radius)
    }
}

fn main() {
    let c = Circle { x: 0.0, y: 0.0, radius: 2.0 };
    println!("{}", c.area());
}
```

以上代码输出`12.566371`。

方法与普通函数的区别之一是方法的第一个参数使用了特殊的写法，写法有三种：`self`、
`&self`和`&mut self`，它们分别表示数据对象的三种类型：栈对象、引用、可变引用。

我们一般都使用`&self`，因为大多数情况下我们倾向于借用数据的所有权，此外大多数情
况下我们也倾向于使用不可变引用。以下是三种写法的示例：

```rust
struct Circle {
    x: f64,
    y: f64,
    radius: f64,
}

impl Circle {
    fn reference(&self) {
       println!("taking self by reference!");
    }

    fn mutable_reference(&mut self) {
       println!("taking self by mutable reference!");
    }

    fn takes_ownership(self) {
       println!("taking ownership of self!");
    }
}
```

数据结构的方法无须定义在一个`impl`块中，你完全可以将它们分开写：

```rust
struct Circle {
    x: f64,
    y: f64,
    radius: f64,
}

impl Circle {
    fn reference(&self) {
       println!("taking self by reference!");
    }
}

impl Circle {
    fn mutable_reference(&mut self) {
       println!("taking self by mutable reference!");
    }
}

impl Circle {
    fn takes_ownership(self) {
       println!("taking ownership of self!");
    }
}
```

# 链式方法调用

之前我们见到了`foo.bar().baz()`这样的连续的方法调用，我们称之为`链式方法调用`，
看下面的例子：

```rust
struct Circle {
    x: f64,
    y: f64,
    radius: f64,
}

impl Circle {
    fn area(&self) -> f64 {
        std::f64::consts::PI * (self.radius * self.radius)
    }

    fn grow(&self, increment: f64) -> Circle {
        Circle { x: self.x, y: self.y, radius: self.radius + increment }
    }
}

fn main() {
    let c = Circle { x: 0.0, y: 0.0, radius: 2.0 };
    println!("{}", c.area());

    let d = c.grow(2.0).area();
    println!("{}", d);
}
```

可以看到方法`grow`返回了一个新的`Circle`实例：

```rust
# struct Circle;
# impl Circle {
fn grow(&self, increment: f64) -> Circle {
# Circle } }
```

因此我们可以接着在`grow`的返回值上调用`Circle`的方法。

# 静态方法

你还可以在`impl`块中定义不包含`self`的函数，此函数即为静态方法，示例如下：

```rust
struct Circle {
    x: f64,
    y: f64,
    radius: f64,
}

impl Circle {
    fn new(x: f64, y: f64, radius: f64) -> Circle {
        Circle {
            x: x,
            y: y,
            radius: radius,
        }
    }
}

fn main() {
    let c = Circle::new(0.0, 0.0, 2.0);
}
```

上面代码中的静态方法`new`向我们返回了一个新的`Circle`实例。注意，静态方法不属于
任何实例，因此我们使用`Struct::function()`这种方式对其进行调用。

# `Builder`构造模式

现在假设我们把`Circle`的代码封装起来给他人使用，其他人在创建新的`Circle`实例时
应该只需对自己感兴趣的部分进行初始化，其它未被初始化的成员应该有合理的初始值。
Rust并没有向我们提供方法重载、命名参数等特性，我们的一般做法是创建一个`Builder`
类型专门向代码库的使用者提供实例的创建方法，具体示例如下（从设计模式的角度来看，
Builder相当于工厂类）：

```rust
struct Circle {
    x: f64,
    y: f64,
    radius: f64,
}

impl Circle {
    fn area(&self) -> f64 {
        std::f64::consts::PI * (self.radius * self.radius)
    }
}

struct CircleBuilder {
    x: f64,
    y: f64,
    radius: f64,
}

impl CircleBuilder {
    fn new() -> CircleBuilder {
        CircleBuilder { x: 0.0, y: 0.0, radius: 1.0, }
    }

    fn x(&mut self, coordinate: f64) -> &mut CircleBuilder {
        self.x = coordinate;
        self
    }

    fn y(&mut self, coordinate: f64) -> &mut CircleBuilder {
        self.y = coordinate;
        self
    }

    fn radius(&mut self, radius: f64) -> &mut CircleBuilder {
        self.radius = radius;
        self
    }

    fn finalize(&self) -> Circle {
        Circle { x: self.x, y: self.y, radius: self.radius }
    }
}

fn main() {
    let c = CircleBuilder::new()
                .x(1.0)
                .y(2.0)
                .radius(2.0)
                .finalize();

    println!("area: {}", c.area());
    println!("x: {}", c.x);
    println!("y: {}", c.y);
}
```

如上所示，`CircleBuilder`提供了`Circle`的实例构造方法。首先通过`new`初始化默认
参数，然后有选择的调用`x`、`y`和`radius`方法对各个成员进行具体设置，最后通过
`finalize`得到设置好的`Circle`实例。
